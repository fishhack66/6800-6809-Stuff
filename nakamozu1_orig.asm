
************************
*
* NAKAMOZU TINY BASIC
* FOR 6800
* VER.6.0
*
* ASSEMBLED BY
* HARUO YAMASHITA
* 1978,10
*
************************

************************
*
* MACHINE-READABLE
* SOURCE FILE WITH
* ENGLISH COMMENTS BY
* DAVE HASSLER
* 2025,JUNE
*
************************

* Additional comments by me (dh) in lower case.
* Assemble with as0 cross assembler, originally
* for PC, ported to Linux (or just about anything, really).

* CAVEAT: Yamashita's handwritten comments are translated
* poorly (by me); someone who can read kanji and understands
* Japanese much better than myself should retranslate
* these properly.  But in the meantime, it's good enough
* to figure out what's going on and get started to
* adapting NTB to other 6800 systems.  Also, Haruo's
* excellent label name choices are a huge help.  -- dh

*** BEGIN ORIGINAL SOURCE ***

*
* OPERATING SYSTEM
*
INI4	EQU	$341C	I/O
INEEE	EQU	$35E6	"
OUTEEE	EQU	$3476	"
BREAK	EQU	$369B	"
NEG	EQU	$3C06	GRAPHIC SUBROUTINES
PICK	EQU	$3BF7	"
SET	EQU	$3BD7	"
RESET	EQU	$3BE8	"
REVERS	EQU	$3BF0	"
VRAMPR	EQU	$3CB6	OPTION (SCREEN PRINT ROUTINE)
*
DISP	EQU	$A094	DISPLAY POINTER FOR I/O 
*
************************

*
* SYSTEM ADRS
*
STACK	EQU	$A047	STACK
IXSTCK	EQU	$A080	"
VRAM	EQU	$C0	VRAM UPPER ADDRESS 
PIACRB	EQU	$E006	H68 KEY SCAN (Hitachi H68TR SBC)
*
************************

*
* BASIC WORK
*
	ORG	$0000
VTOP	RMB	54	VARIABLE AREA @-Z
BOP	RMB	2	SYSTEM VARIABLES [
EOP	RMB	2	                 \
MEMEND	RMB	2	                 ]
IXV	RMB	20	INDEX VARIABLES %0-%9
WKA	RMB	2	GENERAL WORK AREA
WKB	RMB	2	"
WKC	RMB	2	"
XS	RMB	2	"
SPS	RMB	2	"
MDS	RMB	2	MDS SAVE
FS	EQU	*	SAVE FLAG
ADP	RMB	4	+ ADRS SETTINGS WORK
RNDS	RMB	2	RANDOM NUMBER REGISTER
FLOD	RMB	1	LOAD FLAG
FAUT	RMB	1	AUTO FLAG
LPCT	RMB	1	LOOP COUNTER
CHCT	RMB	1	OUTPUT CHARACTER COUNT REGISTER
WKUSE	RMB	2	USING FLAG + WORK
*
	RMB	2
*
LNB	RMB	2	LINE NUMBER REGISTER
EOB	RMB	2	INPUT BUFFER END ADDRESS
EADRS	RMB	2	TEXT ??? PROGRAM COUNTER
XSP	RMB	2	IX ??? STACK POINTER
CSP	RMB	2	???
FSP	RMB	2	FOR/NEXT STACK POINTER
DP	RMB	2	READ/DATA POINTER
BFFR	RMB	72	INPUT BUFFER
EOBF	EQU	*
	RMB	8	gosub and do/until stack?
CSTCK	EQU	*
	RMB	56	FOR/NEXT STACK
FSTCK	EQU	*
*
************************
*
	ORG	$0100
*
START	JMP	CSTART	COLD START
WSTRT	JMP	END	WARM START
*
BGNTXT	FDB	$0C60	TEXT START ADRS DATA
ENDTXT	FDB	$33FF	TEXT END ADRS DATA
*
LINEIN	LDAA	FLOD	INPUT SELECTION SWITCHING
	BNE	CSTIN
	LDAA	FLOD+1
	BEQ	LN2
	LDX	#LNB	AUTOMATIC CODE PROCESSING
	CLRB
	LDAA	#$0A
	JSR	ADBA
	JSR	PNUM
	JSR	OUTS
	BRA	LN6
*
LN1	BSR	CR1	PROMPT OUTPUT
LN2	LDAA	#$3E	'>'

	BSR	COT
	FCB	$8C	(2 BYTES SKIPPED)
LN3	BSR	CR2
LN4	LDX	#BFFR+1
LN5	DEX
	CPX	#BFFR-1
	BEQ	LN3
LN6	EORA	RNDS	RANDOM INITIAL VALUE CHANGE
	STAA	RNDS
	BSR	IN
	STAA	0,X
	CMPA	#$0F	RUBOUT?
	BEQ	LN5
	CMPA	#$0D	CR PROCESSING
	BNE	LN7
	CLR	0,X
	STX	EOB
	BRA	CR2
LN7	CMPA	#$18	DID IT DISAPPEAR?
	BEQ	LN1
	CMPA	#$1F
	BCS	LN6
	INX
	CPX	#EOBF
	BNE	LN6
ERR1	LDAB	#$01
	JMP	ERR
*
IN	JSR	INEEE
	CMPA	#$03	CTRL-C?
	BEQ	END
	RTS
*
CSTIN	BSR	IN
	CMPA	#$02
	BNE	CSTIN
	BRA	LN4
*
CR1	JSR	CR
CR2	LDX	#BFFR
	CLR	CHCT
RTN0	RTS
*
PTST	LDX	BOP
	CLR	0,X
	INX
DEL2	STX	EOP
	LDAA	#$80	TEXT APERATURE MARK (?)
	STAA	0,X
	RTS
*
BRK	PSHA		BREAK?
	JSR	BREAK
	BNE	*+4
	BSR	IN
	PULA
	RTS
*
LOAD	BSR	PTST
APPEND	BSR	CNT11
	STAA	FLOD
	BRA	EDIT
*
CNT11	LDAA	#$11
COT	JMP	OUT
*
AUTO	TPA		AUTOMATIC LINE
	STAA	FAUT
	JSR	CLCPL
	SUBA	#$0A
	SBCB	#$00
SETLN	STAA	LNB+1
	STAB	LNB
	RTS
*
STOP	JSR	PRINT	'STOP' LOGIC
	JSR	PSHX
	BRA	END1
*
CSTART	JSR	INI4	COLD START INITIALIZE
	LDX	BGNTXT
	STX	BOP
	LDX	ENDTXT
	STX	MEMEND
*
NEW	BSR	PTST	'NEW'
END	LDS	#STACK	'END'
	JSR	INITP
END1	LDX	#READY	'READY'
	JSR	MGOUT
	JSR	CR
	TPA		DIRECT MODE PROCESSING
	STAA	EADRS	(MAKE EXECUTION ADRS NEGATIVE)
*
*  @ERR ROUTINE, CMD & EDIT ROUTINE
*
EDIT	LDS	#STACK
ED1	JSR	LINEIN
	JSR	PKUP
	BEQ	ED1
	JSR	ATOB	ASCII --> BINARY
	BCC	DRCT1	BRANCH TO DIRECT MODE
	BSR	SETLN	GOTO SET LINE NUMBER
	BSR	ED2	TO EDITOR
	BRA	EDIT
*
ED2	STX	XS	(EDITOR)
	STS	SPS
	JSR	SCHLIN	CHANGE THE ADDRESS IN THE LINE NUMBER
	STX	WKC
	BCS	INSERT	THERE'S NOWHERE TO GO
	JSR	NXTL1
	INX
	SEI		HAVE THE SAME LINE NUMBER,
	TXS		  DELETE THAT LINE AND MOVE
	LDX	WKC	  THE CORRESPONDING TEXT
	DEX		  FORWARD
	BRA	ED4
*
ED3	INX		TRANSFER
	PULB
	STAB	0,X
	BNE	ED3
ED4	INX
	PULB
	STAB	0,X
	CMPB	#$80
	BNE	ED3
*
	STX	EOP
INSERT	LDX	XS
	LDAA	0,X	CALCULATE THE NUMBER
	BEQ	INST4	   OF BYTES TO INSERT
	LDAA	EOB+1
	SUBA	XS+1
	ADDA	#$03
	LDX	EOP
	ADDA	EOP+1
	STAA	EOP+1
	BCC	*+5
	INC	EOP
	JSR	SIZE	CAPACITY CHECK
	BCC	INST1	IF OK
	STX	EOP	IF NG
	BRA	ERR2
*
DRCT1	BRA	DIRCT
*
INST1	LDS	EOP	CALCULATE NEW FINAL
	INX		  IX IS THE OLD POINTER
INST2	DEX		MAKE SPACE
	LDAA	0,X
	PSHA
	CPX	WKC
	BNE	INST2
	LDS	LNB	BINARY TRANSFER
	STS	0,X
	INX
	LDS	XS	TEXT FROM INPUT
	DES
INST3	INX		BUFFER TO TEXT AREA
	PULA
	STAA	0,X
	BNE	INST3
INST4	LDS	SPS
	CLI
	RTS
*
INITP	LDX	#$00	FLAG AND POINTER INITIALIZE
	STX	FLOD	2 BYTES
	STX	FAUT
	STX	WKUSE
	LDX	#FSTCK
	STX	FSP
	LDX	#IXSTCK
	STX	XSP
	LDX	#CSTCK
	STX	CSP
	LDX	BGNTXT
	STX	DP
	RTS
*
* DIRECT MODE
*
DIRCT	JSR	CHVAR
	BCC	RN3
	LDX	#COMAND
	BRA	RN4
*
NXTL1	INX		FIND THE NEXT LINE
NXTL2	INX
REM	TST	0,X
	BNE	NXTL2
	RTS
*
SCHEND	LDX	EADRS	SEARCH FOR LINE NUMBER
	BPL	SL1	IF WISH TO USE ADRS
SCHLIN	LDX	BOP     GOTO THE BEGINNING
	INX
SL1	LDAA	LNB+1	ERROR IF THE INTERMEDIARY
	LDAB	LNB	  NUMBER CANNOT BE FOUND
	BMI	ERR3
	BNE	SL3
	TSTA
	BNE	SL3
ERR3	LDAB	#$03
	FCB	$8C
ERR2	LDAB	#$02
	JMP	ERR
*
SL2	BSR	NXTL1
RS1	INX
SL3	JSR	CPBA
	BHI	SL2
	RTS
*
SUBIF	JSR	CLCPL	IF.UNTIL CONDITIONAL JUDGEMENT
	TSTB
	BNE	*+3
	TSTA
	RTS
*			"IF"
IF	BSR	SUBIF
	BEQ	REM
	BRA	RN2
*
SIZE	LDAA	MEMEND+1   REMAINING MEMORY CALCULATION
	LDAB	MEMEND
	SUBA	EOP+1
	SBCB	EOP
	RTS
*
END2	JMP	END1	EXECUTION MODE
*
RUN	BSR	INITP
	LDX	BOP
	INX
RN1	STX	EADRS	REACHED END OF PROGRAM TEXT
	LDAA	0,X	  OR DIRECT MODE
	ASLA
	LDAA	EADRS
	BLS	END2
	INX
	INX
RN2	JSR	BRK
	JSR	CHVAR	VARIABLE CHECK
	BCS	*+7
RN3	JSR	LET	ASSIGNMENT STMT PENDING
	BRA	RN5
*
	LDX	#STATE	HEX INPUT
RN4	LDS	#STACK
	JSR	TBLJP
RN5	JSR	PKUP
	BNE	RN5
	INX
	BCC	RN1
	BRA	RN2
*
HB1	ROLA		HEX TEXT INPUT
	ASLA
	ASLA
	ASLA
	ASLA
HB2	ROL	WKC
	ROLB
	ASLA
	BNE	HB2
HTOB	INX
	BSR	TSTHEX
	BCS	HB1
	LDAA	WKC
	RTS
*
TSTHEX	JSR	TSTN	CHECK 16
	BCS	RTN2
	SUBA	#$07
	CMPA	#$3A
	CLC
	BLT	RTN2
	CMPA	#$40
RTN2	RTS
*
CPBA	CMPB	0,X	2-BYTE COMPARISON
	BNE	*+4	(??? -->  Z=1 C=0
	CMPA	1,X	(MULTI-STMT --> Z=1 C=1
	RTS		(??? --> Z=0 C=1
*
TSF	STX	XS
	LDX	#FRNEXT	(TABLE SEARCH)
TBLSCH	STS	SPS	SP <-- TEXT
	SEI		IX <-- TABLE
TS1	LDS	XS
	DES
	INX
TS2	INX
	PULA
	TAB
	SUBB	0,X
	ASLB
	BEQ	TS3	(NOTE: 'LETTERS ARE CHEAP')
	LDAB	0,X	ABBREVIATIONS
	INX
	BPL     *-3	to LDAB above
	CMPA    #$2E	'.'
	BEQ     TS4
	COMB
	BNE	TS1	IF NOT AT THE END OF TABLE
	BRA	TS5
*
TS3	BCC	TS2	DID YOU FIND A MATCH?
	INX
TS4	INS
	STS	XS
TS5	LDS	SPS
	CLI
	RTS
*
PRINT	CLR	WKUSE	'USING' FLAG CLEAR
	BSR	PK1	1-BYTE PICKUP
	BEQ	PR4	(???)
PR1	BSR	PR7
	BEQ	PR2	THE LAST 'OR' HAS BEEN REACHED
	STX	XS
	LDX	#FMT	FORMATTER TABLE JUMP
	JSR	TBLJP
PR2	BSR	PK1
	BEQ	PR4
	CMPA	#$3B	';' IF
	BEQ	PR3
	CMPA	#$2C	',' IF
	BNE	ERR4
	BSR	PR6
PR3	INX
	BSR	PK1
	BNE	PR1
	RTS
*
PK1	JMP	PKUP
*
PR4	JMP	CR
*
PR5	JSR	OUTS	',' PROCESS
PR6	LDAA	CHCT
	BITA	#$07
	BNE	PR5
	RTS
*
CHR	JSR	CLCPL	CHR$ PROCESS
AOT	JMP	OUT
*
TAB1	JSR	CLCPL
	TAB
	BRA	TAB2
*
	JSR	OUTS
TAB2	CMPB	CHCT
	BHI	*-5	to JSR OUTS above
	RTS
*
PR7	BSR	PK1	LITERAL STRING PROCESSING
	CMPA	#$22	'"'
	BEQ	*+6	to TAB below
	CMPA	#$27	apostrophe
	BNE	RTN3
	TAB
	INX
	BRA	*+4	to LDAA below
*
PR8	BSR	AOT
	LDAA	0,X
	BEQ	ERR4
	INX
	CBA
	BNE	PR8
RTN3	RTS
*
ERR4	LDAB	#$04
	FCB	$8C
ERR5	LDAB	#$05
	JMP	ERR
*			DIVISION
DIV	LDAA	0,X	DIVISION BY 0 ERR
	ORAA	1,X
	BEQ	ERR5
	BSR	SETCT
	BSR	MDV3
	ROLA
	NEGA
	TAB
	BSR	MDV4
	ROLA
	EORA	#$01
	RORA
	BSR	MDV2	REMAINDER SAVE
	STAA	MDS+1
	STAB	MDS
	JSR	CPBA
	BNE	DV1
	CLRA
	TAB
	INC	3,X
	BNE	DV1	QUOTIENT [M(2,Y)|M(3,X)] (???)
	INC	2,X
DV1	INX
	INX
	RTS
*	various diagrams follow in the handwritten comments:)
MDIV	BSR	SETCT	(IX+2) <-- (IX+2)/(IX)
MDV1	BSR	MDV3	  
	ROLA			<--------------------
	ROLB		[  D  ][  A  ][M(2,X)][M(?,X]
	SUBA	1,X		||	(# OF DESCENTS)
	SBCB	0,X		||
	BSR	MDV4            vv
MDV2	DEC	LPCT	    [ B ][ A ]  (??)
	BNE	MDV1
MDV3	ROL	3,X
	ROL	2,X
	RTS
*
MDV4	PSHB		(NUMBER PROCESSING)
	EORB	0,X
	PULB
	SEC
	BPL	RTN4
ADD	ADDA    1,X
	ADCB	0,X
	CLC
RTN4	RTS
*
SETCT	LDAA	#$10
	STAA	LPCT
	CLRA
	CLRB
	RTS
*			(MULTIPLICATION)
MULTI	BSR	SETCT
MLT1	ASLA
	ROLB		[M(0,X)][M(1,X)] times [M(2,X)][M(3,X)]
	ROL	1,X		      V
	ROL	0,X		[  B  ][  A  ]
	BCC	*+6		      V
	ADDA	3,X		[M(2,X)][M(3,X)]
	ADCB	2,X		      V
	DEC	LPCT		  INX, INX
	BNE	MLT1
	INX
	INX
	JMP	STBA
*			(NUMERIC OUTPUT)
PNUM	LDX	0,X	CONVERT NUMBERS (BINARY)
	STX	WKB
	LDX	#WKB
	BSR	ABSX	ABSOLUTE NUMBER CALC.
	BCS	PU1
	LDAB	WKUSE	USING WORK
	BEQ	PU2
	TBA
	FCB	$8C
PU1	LDAA	#$2D	'-'
	BSR	OUT
PU2	DEX
	DEX
	LDAB	#$0A	DIVISOR 10 SET
	STAB	1,X
	CLR	0,X
	ASRB		LOOP COUNTER 5
PN1	PSHB		DIVIDE BY 10
	BSR	MDIV
	PULB
	PSHA
	DECB
	BNE	PN1
	LDX	#BFFR
	LDAB	#$04
PN2	LDAA	LPCT	LPCT TO 0
	PULA
	BNE	PN3	SUPRESS 0
	STAA	LPCT
	BNE	PN3
	TST	WKUSE	USING (???)
	BEQ	PN4
	LDAA	WKUSE+1
	SUBA	#$30	ascii '0'
PN3	BSR	PN5	ASCII CONVERT AND OUTPUT
PN4	DECB
	BNE	PN2
	PULA		(comments faint...)
PN5	ADDA	#$30
	TST	FAUT
	BEQ	OUT
	STAA	0,X
	INX
OUT	INC	CHCT
OUTC	JSR	BRK
	JMP	OUTEEE
*
ABSX	TST	0,X	CHECK AND ABSOLUTE VALUE
	BPL	RTN5	(more faint comments)
NEGX	NEG	1,X
	BNE	*+4
	DEC	0,X
	COM	0,X
RTN5	RTS
*
CHASC	CMPA	#$40	'@' ASCII CHECK
	BCS	CHV1	  @-Z --> C=1
	CMPA	#$5B	 '['  --> C=0
	RTS
CHV1	CLC
	RTS
*
CHVAR	BSR	PKUP	VARIABLE CHECK
	STX	XS	NEED TABLE LOOKUP?
	CMPA	#$21	'!'    YES C=1   NO C=0
	BEQ	TBL	
	CMPA	#$2E	'.'
	BEQ	TBL
	CMPA	#$2A	'*'
	BEQ	TBL
	BSR	CHASC
	BCC	CHV1
	LDAA	1,X
	CMPA	#$2E	'.'
	BEQ	TBL
	BSR	CHASC
	BCC	CHV1
	RTS
*
ICPKUP	INX		(PICK UP)
PKUP	LDAA	0,X	SKIP SPACES
	CMPA	#$20
	BEQ	ICPKUP
	TSTA		SEPARATER CHECK
	BEQ	RTN6	$00  Z=1 C=0
	CMPA	#$3A	':'  Z=1 C=1
TBL	SEC		OTHER Z=0 C=1
RTN6	RTS
*			SECOND-LEVEL OPERATION
EX1	BSR	PKUP
	CMPA	#$2D	'-' MINUS PROCESSING
	BNE	EX2
	BSR	EX7
	BRA	EX4
EX2	CMPA	#$2B	'+' PLUS PROCESSING
	BEQ	EX3
	DEX
EX3	BSR	TM1
EX4	LDX	XS
	BSR	PKUP
	CMPA	#$2B	'+'
	BNE	EX6
	BSR	TM1	ADDITION
EX5	BSR	EX8
	BRA	EX4
EX6	CMPA	#$2D	'-'
	BNE	RTN7
	BSR	EX7	SUBTRACTION
	BRA	EX5
*
EX7	BSR	TM1
	BRA	NEGX
*
EX8	JSR	CPUL	ADDITION SUBROUTINES
	INX		  NORMAL STACK
	INX
ADBA	ADDA	1,X
	ADCB	0,X
STBA	STAA	1,X
	STAB	0,X
RTN7	RTS
*
ABS	JSR	CUL1	'ABS'
	BSR	TM2
	JSR	ABSX
	LDX	XS
	RTS
*
EX11	ORAB	#$01	COMPARISON OF LOGICAL OPERATORS
	FCB	$8C	CHECK
EX12	ORAB	#$02
	FCB	$8C		RESULT IN ACCB
EX13	ORAB	#$04		>  0000 0001
	INX			=  0000 0010
	FCB	$C1		<  0000 0100
EX14	CLRB			>= 0000 0011
        BSR     PKUP		<= 0000 0110
        CMPA    #$3E	'>'	<> 0000 0101
        BEQ     EX11
        CMPA    #$3D	'='
        BEQ     EX12
        CMPA    #$3C	'<'
        BEQ     EX13
        CLRA
        RTS
*
TM1	BSR	TERM
TM2	STX	XS
	LDX	CSP
RTN8	RTS
*			THIRD-LEVEL OPERATION
EXPR	BSR	EX1
	BSR	EX14
	TSTB
	BEQ	RTN8
	PSHB
	BSR	EX1
	JSR	CPUL	CALCULATIONS (RECURSIVE)
	LDX	CSP	THE NUMBER OF 'EDGES'
	SUBA	1,X	COMPARISON
	SBCB	0,X
	PULB		(very faint comment here)
	BLT	LT	LOGICAL OPERATIONS
	BGT	GT	(faint note at BLT LT. It looks
	TSTA		 like 'GT' is handwritten, crossed out,
	BEQ	EQ	 then with the word TOP)
GT	ASRB		LOGICAL OPERATIONS
EQ	ASRB
LT	ANDB	#$01
	STAB	1,X
	CLR	0,X
	LDX	WKC
	RTS
*			(ASCII --> BINARY)
ATOB	BSR	TSTN	10 CHECK
	BCC	RTN9
	CLRB
	STAB	WKC+1	AS LONG AS THE NUMBERS CONTINUE
ATB1	STAB	WKC
	ANDA	#$0F
	STAA	LPCT
	LDAA	WKC+1
	ASLA		BINARY CHANGE
	ROLB
	ASLA
	ROLB
	ADDA	WKC+1	RESULT: [ B ][ A ]
	ADCB	WKC
	ASLA
	ROLB
	ADDA	LPCT
	STAA	WKC+1
	ADCB	#$00
	INX
	BSR	TSTN	FOR NUMBERS C=1
	BCS	ATB1	OTHERS C=0
	LDAA	WKC+1
	SEC
RTN9	RTS
*			(DECIMAL CHECK)
TSTN	JSR	PKUP	10S C=1  OTHER C=0
	CMPA	#$30	'0'
	CLC
	BLT	*+4
	CMPA	#$3A	':'
	RTS
*			[FIRST-LEVEL CALCULATION]
TERM	BSR	FUNCT
TR1	JSR	PKUP
	CMPA	#$2A	'*'
	BNE	TR3	BASIC CALCULATION PROCESSING
	BSR	TR4
	JSR	MULTI
TR2	STX	CSP
	LDX	XS
	BRA	TR1
TR3	CMPA	#$2F	'/'
	BNE	RTN9
	BSR	TR4	REMOVAL
	JSR	DIV
	BRA	TR2
*			CALCULATION OF EXPRESSIONS (RECURSIVE)
TR4	BSR	FUNCT
	JMP	TM2
INHEX	CLRB		'$' 16S (hex) INPUT
	STAB	WKC
	JSR	HTOB	BINARY
	BRA	CPS2    PLACE ON STACK-PSH
*			'#' PEEK
PEEK	BSR	FUNCT
	JSR	CPUL	AGRUMENT TEST
	BSR	TBAX	[ B A ] --> IX
	LDAA	0,X
	CLRB
	BRA	CPS1	PUSH
*
LITRL	CMPA	2,X	LITERAL CONSTANTS
	BNE	ERR7	(ASCII CONSTANT) PROCESSING
	LDAA	1,X
	CLRB
	INX
	INX
	INX
	BRA	CPS2
*			(FUNCTION TABLE JUMP)
FUNCT	INX
	BSR	ATOB	ASCII --> BINARY
	BCS	CPS2	IF ...
	CMPA	#$23	'#'
	BEQ	PEEK	IF PEEK
	CMPA	#$22	'"'
	BEQ	LITRL	IF LITERAL
	CMPA	#$27	' ' ' (apostrophe)
	BEQ	LITRL
	CMPA    #$24	'$'
	BEQ	INHEX	IF 16 NUMBER (hex)
	JSR	CHVAR	VARIABLE CHECK
	BCC	CUL	BRANCH IF 2 TERMS BORROWED
	LDX	#FUNC	SELECT THE OTHER FUNCTION TABLE
*
TBLJP	JSR	TBLSCH	...AND JUMP
	LDAA	1,X	ADRS TO STACK
	PSHA
	LDAA	0,X
	PSHA
	LDX	XS
	RTS		THEN JUMP VIA RTS
*			(ARITHMETIC STACK PUSH)
CPUSH	BSR	TBAX
	LDAA	1,X	BA <-- (BA)
	LDAB	0,X
CPS1	LDX	XS
CPS2	STX	WKC
	LDX	CSP	TO MAIN STACK
	DEX
	DEX
	CPX	EOB
	BLE	ERR6
CPS3	JSR	STBA
	STX	CSP
CPS4	LDX	WKC
	RTS
*
ERR6	LDAB	#$06
	FCB	$8C
ERR7	LDAB	#$07
	FCB	$8C
ERR8	LDAB	#$08
	JMP	ERR
*
CUL	BSR	VAR	VARIABLES, IX VARIABLES, IX ARRAYS
	BCC	CPUSH	ADRS COMPONENT
CUL1	LDAA	0,X
	CMPA	#$28	'('
	BNE	ERR7
CUL2	INX
CUL3	JSR	EXPR	PROCESSING
CUL4	LDAA	0,X
	CMPA	#$29	')'
	BNE	ERR7
	INX
	RTS
*
TBAX	STX	XS	IX <-- BA
	STAA	WKC+1
	STAB	WKC
	BRA	CPS4
*			"MOD"
MOD	JSR	SUB5
	BEQ	MOD1
	LDAB	MDS	WITHOUT ARGUMENTS
	LDAA	MDS+1
	BRA	CPS2
*
MOD1	INX		WITH 2 ARGUMENTS
	JSR	EXPR
	BSR	COMMA
	BNE	ERR8
	INX
	BSR	CUL3
MOD2	STX	WKC
	LDX	CSP
	JSR	DIV	DIVIDE TO GET REMAINDER
	BRA	CPS3
*
COMMA	LDAA	0,X
	CMPA	#$2C	','
	RTS
*			"RND"
RND	LDAB	RNDS+1	UPDATE RANDOM NUMBER REGISTERS
	LDAA	RNDS
	ABA
	ADCB	#$95
	ADCA	#$AB
	STAA	RNDS+1
	STAB	RNDS
	BSR	CPS2	ARITHMETIC STACK PSH
	BSR	CUL1	(???)
	BRA	MOD2	USE REMAINDER AS RANDOM NUMBER
*
USER	JSR     SUB10	"USER"
        BSR     US2
        BRA     CPS1	HERE FOR RETURN
US2	BSR	CCP1	1ST ARGUMENT
	PSHA
	PSHB
	BSR	US3	2ND ARGUMENT
	PSHA
	PSHB
	BSR	US3	3RD ARGUMENT
	PSHA
	PSHB
	TPA
	PSHA
	BSR	CUL4
	STX	XS
	RTI
*
US3	BSR	COMMA
	BNE	US4
	INX
CCP1	JMP	CLCPL
*			WHEN THERE ARE NO ARGUMENTS
US4	CLRA
	CLRB
NOTV	SEC
	RTS
*
VAR	JSR	PKUP	VARIB, IX VARIB, IX ARRAY ADRS
	CMPA	#$25	'%' FOR IX VAR OR ARRAY
	BEQ	ARR
	CMPA	#$40	'@' CHECK VARIB RANGE
	BCS	NOTV
	CMPA	#$5D	']'
	BHI	NOTV
	ANDA	#$3F	VARIABLE ADRS
	ASLA
	CLRB
	INX
	RTS
*			IX VARIABLES AND ARRAYS
ARR	INX
	JSR	TSTN	DECIMAL CHECK
	BCC	ERR14
	INX
	JSR	SUB5
	BEQ	IND
DIR	ANDA	#$0F	ADRS CALCULATION
	ASLA
	ADDA	#IXV
	CLRB
	RTS
*
IND	PSHA		PSH ONTO ARRAY NAME STACK
	JSR	CUL2	RECURSIVE
	PULA
	BSR	DIR	ADRS (???)
	JSR	TBAX	PROCESS ARGUMENTS
	JSR	CPUL1	PUL
	ASLA
	ROLB
	JSR	ADD	ADRS ADDITION
	LDX	XS
	RTS
*
LET3	JSR	VAR	TEXT ENTRY PROCESSING
	BCS	ERR9
LET4	STAA	WKB+1	LEFT SIDE ADRS
	STAB	WKB
	LDAA	0,X
	CMPA	#$3D	'='
	BNE	ERR9
	INX		RIGHT SIDE
	BSR	CLCPL
	STX	XS
	LDX	WKB
	RTS
*
ERR14	LDAB	#$0E
	FCB	$8C
ERR9	LDAB	#$09
	FCB	$8C
ERR10	LDAB	#$0A	
	JMP	ERR
*
THEN	CLR	ADP+3
	JSR	ATOB	FOR LINE NUMBERS, GO TO GO
	BCS	GO1
	JMP	RN2	STATEMENT PROCESSING
*
POKE	JSR	FUNCT	"POKE" "#"
	BSR	CPUL	ADRS CALC
	BSR	LET4	ASSIGNMENTS
	TAB
	BRA	LET2
*
PSHX	STS	SPS	(IX STACK PSH)
	SEI
	TXS
	LDX	XSP	IX STACK OPEN
	CPX	#STACK+3
	BEQ	ERR10
	DEX
	DEX
	STS	0,X
PX1	STX	XSP
	TSX
	LDS	SPS
	CLI
	RTS
*
PULX	LDX	XSP		(IX STACK PSH)
	CPX	#IXSTCK
	BEQ	ERR10
	STS	SPS
	SEI
	LDS	0,X
	INX
	INX
	BRA	PX1
*
CLCPL	BSR	EXPR2		CALCULATE, DIVIDE [B,A]
CPUL	STX	WKC	    PLACE IN WORK AREA
CPUL1	LDX	CSP	STACK POINTER
	CPX	#CSTCK
	BEQ	ERR9
	LDAA	1,X
	LDAB	0,X
	INX
	INX
	STX	CSP
	LDX	WKC
RTN13	RTS
*
EXPR1   LDX     XS
EXPR2   JMP     EXPR
*			"GO"
GOTO	CLRA
GOSUB	STAA	ADP+3	"GOSUB"
	BSR	CLCPL	CALC MOVE
GO1	JSR	SETLN	SET IT
	TSTB		IF 0 LEAVE IT AS IT IS
	BNE	GO2
	TSTA
	BEQ	RTN13
GO2	TST	ADP+3	GOSUB IX
	BEQ	*+4
	BSR	PSHX	IX PUSH
	LDX	EADRS	IS THE DESTINATION BEFORE
	JSR	CPBA	  OR AFTER WHERE WE ARE?
	BCC	GO3
	ROR	EADRS
GO3	JSR	SCHEND	WHAT NUMBER TO SEARCH?
	BCS	ERR11
	JMP	RN1
*			(ASSIGNMENT)
LET	CMPA	#$23	'#'
	BEQ	POKE
LET1	JSR	LET3
	STAA	1,X	ASSIGN IT
LET2	STAB	0,X
	LDX	XS
	RTS
*			"FOR"
FOR	BSR	LET1	INITIAL PARAMETERS FOR CONTROL VARIABLES
	LDAA	WKB+1	STORE IN WORK AREA
	LDAB	WKB
	JSR	CPS2	PUSH TO STACK
	JSR	TSF	'TO' CHECK
	CPX	#TO
	BNE	ERR12
	BSR	EXPR1	FINAL PARAMETER CALC. --> PSH
	JSR	TSF
	CPX	#STEP	'STEP' CHECK
	BEQ	FOR1
	LDAA	#$01	DEFAULT STEP
	CLRB
	JSR	CPS1
	BRA	FOR2
*
FOR1	BSR	EXPR1
	STX	XS
FOR2	LDAA	XS+1	LOOP RETURN ADRS
	LDAB	XS	PSH
	JSR	CPS2
	LDAA	WKB+1	TO WORK AREA
	LDAB	WKB
	LDX	FSP	FOR/NEXT STACK POINTER
	CPX	#FSTCK	(faint text here)
	BEQ	FOR5
	BSR	TSTPM	PARAMETER CHECK
	BCC	FOR4
	LDX	FSP
	CPX	#CSTCK
	BNE	FOR5
ERR12	LDAB	#$0C
	FCB	$8C
ERR11	LDAB	#$0B
	FCB	$8C
ERR13	LDAB	#$0D
	JMP	ERR
*
FOR4	BSR	INX8	FROM THE STACK
FOR5	BSR	FORPSH	FOR/NEXT STACK
	BRA	NXT3	TRANSFER
*
TSTPM	JSR	CPBA	TEST PARAMETER 2, BYTE COMPARISON
	BEQ	RTN11	  ALL OTHER FOR/NEXT PARAMETERS
	BSR	INX8	  <-- INSIDE THE LOOP
TPM1	CPX	#FSTCK
	BNE	TSTPM	(?? something about the carry flag)
	SEC
RTN11	RTS
*
FORPSH	BSR	*+2	(???, something about IX)
	BSR	*+2
	JSR	CPUL
	DEX
	DEX
	JMP     STBA
*			"NEXT"
NEXT	JSR	VAR	CALC ADRS LIMIT
	STX	XS
	LDX	FSP	FOR/NEXT STACK POINTER
	BCC	NXT1
	LDAA	1,X	(???)
	LDAB	0,X
NXT1	BSR	TPM1	PARAMETER CHECK
	BCS	ERR13
	STX	FSP
	LDAA	5,X	MARK IT
	LDAB	4,X
	LDX	0,X	PARAMETER ADRS
	JSR	ADBA	ADD STEP
	LDX	FSP
	CMPB	2,X	COMPARE TOP AND BOTTOM OF LOOP
	SEC		(???)
	BLT	NXT2
	CLC
	BGT	NXT2
	CMPA	3,X
	BEQ	NXT4
NXT2	RORA		[c]->[ byte  ]->[c]
	EORA	4,X	(unclear)
	BMI	NXT4
	BSR	INX8
NXT3	STX	FSP
	LDX	XS
	RTS
*
INX8	INX
	INX
	INX
	INX
	INX
	INX
	INX
	INX
	RTS
*
NXT4	LDX	6,X	FOR/NEXT TEXT ADRS
	RTS
*
INPUT	STX	WKB
	LDAA	WKB	DIRECT MODE ERROR CHECK
	BEQ	ER1
	LDX	EOB	INPUT BUFFER NAME (???)
	STX	WKA
	LDX	WKB
	JSR	PR7	REAL STRING PRINT
	BNE	INP1
	BSR	INP3
INP1	JSR	VAR	INPUT ADRS CALCULATION
	BCS	ER1	IF IX VARIABLES
	PSHA		ADRS PSH
	PSHB
	STX	WKB
	LDX	WKA
	BSR	PKUP1
	BNE	INP2	CONTINUE WITH VARIABLE INPUT
INA	LDAA	#$3F	'?'
	BSR	OUT1	PRINT ? AND SPACE
	BSR	OUTS
	JSR	LN4	INPUT BUFFER IN
INP2	JSR	PKUP
	CMPA	#$24	'$' MISS CHECK
	BCS	MISS
	CMPA	#$5B	'['
	BCS	OK
MISS	STX	WKC	RETRY INPUT
	LDX	#REENT
	JSR	MGOT
	BRA	INA
*
OK	JSR	CLCPL	('formula leakage'???)
	BSR	INP3
	STX	WKA
	TSX		PSH ADRS, LOAD TO IX
	LDX	0,X
	INS
	INS
	JSR	STBA
	LDX	WKB
	BSR	PKUP1
	BEQ	RTN12
	CMPA	#$2C	','
	BNE	ER1	IS NOT ',' GO AROUND
	INX		  ELSE ENTER MORE
	BRA	INP1
*
ER1	JMP	ERR1
*
INP3	BSR	INP4
	BNE	RTN12
	INX
RTN12	RTS
*
INP4	PSHA
	BSR	PKUP1
	CMPA	#$2C	','
	PULA
	RTS
*
PKUP1	JMP	PKUP
*
OUTS	LDAA	#$20	SPACE
OUT1	JMP	OUT
*
DDLY	BSR	DELAY	1 SECOND (at 1 MHz E, this seems right)
DELAY	STX	WKC	0.5 SECOND
	LDX	#$E100
DEL1	DEX
	BNE	DEL1
	LDX	WKC
	RTS
*
SAVE	LDAA	#$12	SETUP FOR CASSETTE SAVE
	BSR	OUT1
	STAA	FS
	BSR	DDLY
	BRA	LST1
*
LIST	CLR	FS
LST1	CLRB
	STAB	WKUSE
	LDAA	#$01	SET LINE TO 1
	JSR	SETLN
	LDAB	#$7F	(largest poss. line # = BA)
	LDAA	#$FF
	PSHA
	BSR	PKUP1	LOOK FOR ARGUMENTS
	PULA
	BEQ	LST2	
	JSR	CLCPL
	JSR	SETLN
	BSR	INP4
	BNE	LST2
	INX
	JSR	CLCPL
LST2	STAA	SPS+1	
	STAB	SPS
	LDX	SPS
	BGT	LST3	TEST SECOND ARGUMENT
	LDX	#$7FFF	LIST TO END
	STX	SPS
LST3	JSR	SCHLIN
	FCB	$8C
*
LST4	BSR	LST5	UNTIL THE END
	LDAA	SPS+1	LIST
	LDAB	SPS
	JSR	CPBA
	BCC	LST4
CNTCRD	STX	WKC	CASSETTE I/O CANCEL
	LDX	#CNT	CONTROL OUTPUT ('CORD')
	BSR	MGOT
TOEND	JMP	END	NOT IN EDIT MODE
*			LIST PROCESSING SUBROUTINE
LST5	LDAA	#$02	'CORD' (???)
	BSR	OUT1	
	BSR	LST7
	INX
	LDAA	#$20	' '
	BSR	MGOT1	FOLLOWING SPACE, TEXT BEHAVIOR
	BSR	CR	
	LDAA	FS	SAVE FLAG
	BNE	DELAY	DELAY FOR SAVE
	RTS
*
CR	STX	WKC
	LDX	#CRLF
MGOT	BSR	MGOUT
	CLR	CHCT
LST6	LDX	WKC
	RTS
*
LST7	STX	WKC
LST8	JSR	PNUM	CONVERT BINARY TO ASCII
	BRA	LST6	OUTPUT
*
MGOT1	JSR	OUT	OUTPUT UP TO $00, BY IX
	INX
MGOUT	LDAA	0,X
	BNE	MGOT1
	INX
	RTS
*
ERR	LDS	#STACK	INITIALIZE STACK
	BSR	CR	START A NEW LINE
	LDX	#ERROR	GET ERROR NUMBER
	BSR	MGOUT
	TBA
	CLRB		ERROR NUMBER
	STAB	WKUSE	OUTPUT
	BSR	CCP3
	LDX	EADRS
	BMI	TOEND
	BSR	CR	DIRECT MODE IF NOT ABOVE (running)
	BSR	LST5	LIST THE ERROR LINES
	BRA	TOEND
*
USING	LDAB	0,X	'USING' PROCESSING
	STAB	WKUSE
	LDAB	1,X
	STAB	WKUSE+1
	INX
	INX
*
CCP2	JSR	CLCPL	EXPRESSION VALUE OPERATIONS
CCP3	PSHA		[BA] VALUE
	PSHB
	STX	WKC
	TSX
	BSR	LST8	OUTPUT AS ASCII
	PULB
	PULA
	CLR	WKUSE
	RTS
*
OHL	LSRA	WORK ON UPPER 4 BITS
	LSRA
	LSRA
	LSRA
OHR	ANDA	#$0F	HEXIDECIMAL OUTPUT WITH THOSE BITS
	CMPA	#$0A
	BCS	*+4
	ADDA	#$07
	ADDA	#$30	'0'
TOOUT	JMP	OUT
*
O4H	PSHA		2 BYTES OF 4-DIGIT HEX
	TBA
	BSR	O2H
	PULA
O2H	PSHA
	BSR	OHL
	PULA		1 BYTE OF 2-DIGIT HEX
	BRA	OHR
*			"HDT" OR "HDF"
HD	LDAA	#$24	'$'
	BSR	TOOUT	OUTPUT '$'
	LDAA	0,X
	INX
	CMPA	#$54	'T'
	BEQ	HDT
HDF	JSR	CLCPL	HDF PROCESSING
	BSR	O4H
TOOUTS	JMP	OUTS
*
HDT	JSR	CLCPL	HDT PROCESSING
	BSR	O2H
	BRA	TOOUTS
*			"GET$" NUMBER
GET	JSR	IN	
	CLRB
GET1	JMP	CPS2
*
COPY	JSR	VRAMPR	(OPTION) "COPY" STATEMENT
	BRA	G1
*
* GRAPHIC		[GRAPHICS INSTRUCTIONS]
*			"NEG"
NEGB	JSR	NEG
	BRA	G1
*
PICKB	BSR	SUB2	"!P(X,Y) STATEMENT
	BSR	SUB4
	JSR	PICK
	TBA
	CLRB
	LDX	XS
GE1	JMP	CPS2
*
SETPT	LDAA	0,X	"!W(X,Y) STATEMENT
	CMPA	#$57	'W'
	BNE	G2
	BSR	SUB3
	JSR	SET
G1	LDX	XS
	RTS
*
G2	CMPA	#$42	"!B(X,Y) STATEMENT
	BNE	G3
	BSR	SUB3
	JSR	RESET
	BRA	G1
*
G3	CMPA	#$52	"!R(X,Y) STATEMENT
	BNE	ERR15
	BSR	SUB3
	JSR	REVERS
	BRA	G1
*
SUB5	LDAB	0,X
	CMPB	#$28	'('
	RTS
*
SUB3	BSR	SUB1	GRAPHIC
SUB4	CMPA	#$40	AUGMENT CYCLE
	BCC	ERR16	CHECK
	CMPB	#$30
	BCC	ERR16
	RTS
*
SUB1	INX
	BSR	SUB5
	BNE	ER9
SUB6	INX
SUB2	JSR	SUB7	(???)
	ORAB	ADP
	BNE	ERR16
	TAB
	LDAA	ADP+1
	RTS
*
ERR15   LDAB    #$0F
	FCB	$8C
ERR16	LDAB	#$10
        JMP     ERR
*			CLR(X,Y) & KEY(X,Y)
CMP	BCC	ERR16	ARGUMENT CHECK
	CBA
	BGT	ERR16
	RTS
*			"CLR(X,Y)"
CLR	BSR	SUB5
	BNE	ALLCLR
	BSR	SUB6
	CMPB	#$10
	BSR	CMP
C1	PSHA
	BSR	C3	SECOND ARGUMENT
	ADDB	#$20
	ADCA	#$00
	STAA	ADP+2
	STAB	ADP+3
	PULB
	BSR	C3	FIRST ARGUMENT
	STAA	ADP
	STAB	ADP+1
	LDAB	#$DF	<-- SPACE CORD. CHANGED TO $20 FOR VRAM
	LDX	ADP	(above was LDAB #$FF-' ' in original)
C2	STAB	0,X
	INX
	CPX	ADP+2
	BNE	C2
	LDX	XS
	RTS
*
ALLCLR	LDAB	#$0F
	CLRA
	BRA	C1
*
C3	CLRA		ADRS CALCULATION FROM ARGUMENTS
	LSRB
	RORB
	RORB
	RORB
	ADCA	#VRAM	VRAM START ADRS, UPPER BYTE
	RTS
*
ER9   JMP     ERR9
*			"CURS(X,Y)" X=ACCA Y=ACCB
CURS	BSR	SUB10
	BSR	SUB2	PULL
	CMPA	#$20	CURSOR'S CATEGORY
	BCC	ERR16
	CMPB	#$10
	BCC	ERR16
	STAA	CHCT
	BSR	C3
	STAA	DISP	CALCULATED ADRS
	LDAA	CHCT	WRITE TO THE OS ADRS REGISTER
	ABA
	STAA	DISP+1
	RTS
*			"SGN(X)" FUNCTION
SGN	JSR	CUL1	(something about acca abd accb...)
	JSR	CPUL
	TSTB
	BMI	MINS
	BNE	PLS
	TSTA
	BEQ	ZERO	(a table: ? = 1
PLS	CLRB		          ? = 0
	LDAA	#$01	          ? = -1)
	BRA	ZERO
*
MINS	LDAA	#$FF
	TAB
ZERO	JMP	CPS2
*
ER7	JMP	ERR7
*
SUB10	JSR	SUB5
	BNE	ER7
	INX
	RTS
*
SUB11	BSR	SUB10	something about '2-argument processing'...
SUB7	JSR	CLCPL
	STAA	ADP+1
	STAB	ADP
	JSR	COMMA
	BNE	ER9
	INX
	JSR	CLCPL	???
	PSHA
	JSR	CUL4
	PULA
	STX	XS
	RTS
*			"AND(X,Y)" FUNCTION
AND	BSR	SUB11
	ANDA	ADP+1
	ANDB	ADP
AND1	JMP	CPS2
*			"OR(X,Y)" FUNCTION
OR	BSR	SUB11
	ORAA	ADP+1
	ORAB	ADP
	BRA	AND1
*			"XOR(X,Y)" FUNCTION
XOR	BSR	SUB11
	EORA	ADP+1
	EORB	ADP
	BRA	AND1
*			"RESTORE" STATEMENT
RES	JSR	CLCPL	???
	STX	WKA
	LDX	BOP	FIND TEXT AT START
	JSR	RS1
	BCS	ER11
	DEX
	BRA	RE4
*			"READ" FUNCTION
READ   STX     WKA
        LDX     DP	DATA POINTER
        JSR     PKUP	PICKUP TEXT
        CMPA    #$2C	','
        BEQ     RE3	NEXT DATA ELEMENT
        TSTA
        BEQ     RE2	IF AT END OF DATA STMT, USE THIS
        JMP     ERR1
*
RE1	JSR	NXTL1	FIND END OF NEXT LINE
RE2	LDAA	1,X
	CMPA	#$80	END OF TEXT?
	BEQ	ERR17
	LDAA	3,X	
	INX
	CMPA	#$2A	'*'
	BNE	RE1	IF NOT, WRITE THE NEXT LINE
	INX
	INX
RE3	INX
	JSR	EXPR	CALCULATE THE VALUE OF DATA
RE4	STX	DP
	LDX	WKA
	RTS
*			"DEL"
DEL	BSR	RES	SEARCH FOR ADRS IN QUESTION & STORE
	LDX	DP	
	INX
	JSR	DEL2	IF FROM THE ??? ROW, PROC. AS NEW
	JMP	END
*
ER11	JMP	ERR11
*
ERR17	LDAB	#$11
	JMP	ERR
*			"KEY" FUNCTION (NOTE 'HGFM' [???])
KEY	JSR	SUB5
	BEQ	K0
	LDAB	#$07
	CLRA
	BRA	K1
*
K0	JSR	SUB6	SEPERATE NOTE
	CMPB	#$06
        JSR     CMP
	INCB
K1	STAA	PIACRB
	PSHA
	LDAA	PIACRB
	CMPA	#$55
	BLS	K2
	PULA
	INCA
	CBA
	BNE	K1
	LDAA	#$64
	FCB	$C1
K2	INS
	CLRB
	JMP	CPS2
*			"UNTIL"
UNTIL	JSR	SUBIF	VALUE OF EXPRESSION
	BEQ	UNT	EVALUATE
	JSR	PULX	IF GOOD, IX STACK PULL
        LDX	WKC	  TO NEXT LINE TO EXECUTE
	RTS
*
UNT	LDX	XSP	IF NOT GOOD,
	LDX	0,X	  EXTRACT CONTENT OF IX STACK
	INX		  AND ITS ADRS ^
	RTS
*
CNT	FCB	$03	SAVE, LIST CONTROL CODES FOR RELEASE
	FCB	$13
	FCB	$14
	FCB	$00
*			'ERROR NO.'
ERROR   FCB     $45,$52,$52,$4F,$52,$20,$4E,$4F,$2E,$00
*			CRLF --> 'READY' (note BEL char.)
READY	FCB	$0D,$0A,$52,$45,$41,$44,$59,$07,$00
*
CRLF	FCB	$0D,$0A,$00
*			'RE-ENTER'
REENT   FCB     $52,$45,$2D,$45,$4E,$54,$45,$52,$00
*
* NOTE: TABLE OF KEYWORDS - MOST SIG. BIT OF LAST CHAR IS SET
*
Z	EQU	$80
*
COMAND	EQU	*-2
	FCC	'LIS'
	FCB	$54+Z
	FDB	LIST
	FCC	'LOA'
	FCB	$44+Z
	FDB	LOAD
	FCC	'RU'
	FCB	$4E+Z
	FDB	RUN
	FCC	'E'	'EXIT'
	FCB	$58+Z
	FDB	$F0B1	MONITOR 'CONTRL' ADRS
	FCC	'AUT'
	FCB	$4F+Z
	FDB	AUTO
	FCC	'NE'
	FCB	$57+Z
	FDB	NEW
	FCC	'SAV'
	FCB	$45+Z
	FDB	SAVE
	FCC	'APPEN'
	FCB	$44+Z
	FDB	APPEND
	FCC	'DE'
	FCB	$4C+Z
	FDB	DEL
*
STATE	EQU	*-2
	FCC	'NEX'
	FCB	$54+Z
	FDB	NEXT
	FCC	'UNTI'
	FCB	$4C+Z
	FDB	UNTIL
	FCC	'GOT'
	FCB	$4F+Z
	FDB	GOTO
	FCC	'GOSU'
	FCB	$42+Z
	FDB	GOSUB
	FCC	'THE'
	FCB	$4E+Z
	FDB	THEN
	FCC	'FO'
	FCB	$52+Z
	FDB	FOR
	FCC	'D'	(do statement)
	FCB	$4F+Z
	FDB	PSHX
*
	FCB	$A1	('!' + z) GRAPHIC STATEMENT
	FDB	SETPT
*
	FCC	'RE'
	FCB	$54+Z
	FDB	PULX
	FCC	'INPU'
	FCB	$54+Z
	FDB	INPUT
	FCC	'I'
	FCB	$46+Z
	FDB	IF
	FCC	'PRIN'
	FCB	$54+Z
	FDB	PRINT
	FCC	'CL'
	FCB	$52+Z
	FDB	CLR
	FCC	'CUR'
	FCB	$53+Z
	FDB	CURS
	FCC	'NE'
	FCB	$47+Z
	FDB	NEGB
	FCC	'RESTOR'
	FCB	$45+Z
	FDB	RES
	FCC	'RE'
	FCB	$4D+Z
	FDB	REM
	FCB	$AA	'DATA' SYMBOL (* + z)
	FDB	REM
	FCC	'EN'
	FCB	$44+Z
	FDB	END
	FCC	'STO'
	FCB	$50+Z
	FDB	STOP
*
	FCC	'COP'	OPTIONAL 'COPY' STATEMENT (DIY)
	FCB	$59+Z	  SENDS SCREEN TO A PRINTER
	FDB	COPY
*
	FCB	$FF	NOT A VALID STATEMENT
	FDB	ER9	  SEND TO ERROR NO. 9
*
FUNC	EQU	*-2
	FCC	'RN'
	FCB	$44+Z
	FDB	RND
	FCC	'REA'
	FCB	$44+Z
	FDB	READ
	FCC	'AB'
	FCB	$53+Z
	FDB	ABS
	FCC	'MO'
	FCB	$44+Z
	FDB	MOD
	FCC	'!P'
	FCB	$28+Z
	FDB	PICKB
	FCC	'USE'
	FCB	$52+Z
	FDB	USER
	FCC	'AN'
	FCB	$44+Z
	FDB	AND
	FCC	'O'
	FCB	$52+Z
	FDB	OR
	FCC	'XO'
	FCB	$52+Z
	FDB	XOR
	FCC	'SG'
	FCB	$4E+Z
	FDB	SGN
	FCC	'KE'
	FCB	$59+Z
	FDB	KEY
	FCC	'GET'
	FCB	$24+Z
	FDB	GET
	FCB	$FF	NO MATCHING FUNCTION
	FDB	ERR7	ERROR NO. 7
*
FRNEXT	EQU	*-2
	FCC	'T'
	FCB	$4F+Z
TO	FDB	#$00
	FCC	'STE'
	FCB	$50+Z
STEP	EQU	*
*
FMT	EQU	*-2	[FORMATTER]
	FCC	'CHR'
	FCB	$24+Z
	FDB	CHR
	FCC	'TA'
	FCB	$42+Z
	FDB	TAB1
	FCC	'H'
	FCB	$44+Z
	FDB	HD
	FCC	'USIN'
	FCB	$47+Z
	FDB	USING
	FCB	$FF
	FDB	CCP2
*
PROG	EQU	*
	END
