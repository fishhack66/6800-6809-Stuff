*
*	*****************************
*	*                           *
*	*    T i n y   P I L O T    *
*	*         for 6800          *
*	*                           *
*	*   Original 6502 version   *
*	*     by Nicholas Vrtis     *
*	*            in             *
*	*  MICRO, iss. 16, pg. 41   *
*	*      September, 1979      *
*	*                           *
*	*   Modified for 6800 and   *
*	*  HM-68 homemade computer  *
*	*  by Dave Hasler, 2/2024   *
*	*                           *
*	*****************************
*
*    With KIM-1 I/O and I, L, and P statement
* additions by Bob Applegate, 1980. 
*    Z and X statement additions, plus mod to
* L statement, and title by Dave Hassler, 2023.
*    NV's original comments in upper case,
* all others in lower case (mine with DHH).
*    Any mistakes found below are very likely
* my own. --DHH
*
*    Assemble with AS0 Motorola 6800 Assembler,
*    updated to ANSI-standard C by Jim Newman.
*    (found at: https://github.com/JimInCA/motorola-6800-assembler)
*    Linux: ./as0 TINYPILOT6800.ASM -l >> tinypilot6800.lst
*    A Motorola S-Record will be output.

* **** PAGE ZERO REFERENCES

LST	= $00
FLG	= $02
CHRS	= $03
NAME	= $2B
VARIBS	= $53
IFLAG	= $87
HOLDY	= $88
WORK	= $89
RESULT	= $8B
ANSX	= $8D
SIGNIF	= $8E
OPRATN	= $8F
NUMDSP	= $90
RETURN	= $95
CURAD	= $97
STRING	= $A6

* Uses $A0-$A5 for Bob's ML call variables, if the user
* sets up for the L: statement (variables A-C).
* $D4-$DB used by Bob's RND and INPUT statements --DHH 

STORX	= $ED		<-- these 3 locations used by Bob's KIM-1
STORY	= $EE		additions for safe KIM-1 I/O. 6800: now used for 
OFFSET	= $EF		simulating 6502 X and Y indexing --DHH
CR	= $0D		

***** EXTERNAL ADDRESS REFERENCES
***** not needed, as we're using Bob's I/O for KIM-1. 6800-for HM-68 I/O

*INCHR	= INCH		these are SYM routines
*OUTCHR	= OUTCH
*CRLF	= SAVCR

***** These are for the HM-68, with modified SWTBUG, scratch RAM=$7F00

RETURN	EQU	$E0E3	;RETURN TO PROMPT - CONTRL
OUTCH	EQU	$E1D1	;OUTPUT CHAR ON CONSOLE
INCH	EQU	$E1AC	;INPUT CHAR FROM CONSOLE AND ECHO
PDATA1	EQU	$E07E	;PRINT TEXT STRING @ X ENDED BY $04
OUT2HS	EQU	$E0CA	;PRINT 2 HEX CHARS @ X
OUT4HS	EQU	$E0C8	;PRINT 4 HEX CHARS @ X
INBYTE	EQU	$E055	;INPUT 1 BYTE TO A.


	ORG $0100

**** PRINT TITLE

	JSR WELCOM	go print a welcome line --DHH

**** START OF EDITOR PORTION

START	LDAA	#$80	SET MODE TO EDIT FOR PRT ROUTINE
	STAA	IFLAG
	JSR	SETBGN	SET UP STARTING DATA AREA ADDRESS

**** HERE IS THE START OF EACH NEW LINE

ELINE	LDAA	#$3E	OUTPUT A '>' PROMPT CHARACTER
	JSR 	OUTCH

**** HERE IS WHERE EACH INPUT CHARACTER IS OBTAINED

EGET	JSR 	INCH
	STAA	STORX	CHECK FOR NULLS AND IGNORE
	BEQ 	EGET	SO THEY DON'T GET CONFUSED WITH EOL

	CMPA 	#$5E	IS IT '^'?
	BEQ 	START	YES - START AT BEGINNING AGAIN

	CMPA	#$40	IS IT '@' FOR EXECUTE REQUEST?
	BEQ	EXEC	YES, GO START ON THAT

	CMPA	#$08	IS IT A BACKSPACE?
	BNE	TRYDSP	NO - GO CHECK FOR DISPLAY REQUEST


	DEC	STORY	YES - BACK UP ONE CHARACTER
	BPL 	EGET	BUT CHECK FOR PAST START OF LINE
	INC	STORY	BACKED UP TOO FAR - DISALLOW
	BPL 	EGET	UNCONDITIONAL

TRYDSP	CMPA 	#$2F	IS IT '/' FOR DISPLAY LINE REQUEST?
	BNE 	TRYREP	NO - CHECK FOR REPLACEMENT REQUEST

**** DISPLAY TO THE NEXT CARRIAGE RETURN

	JSR 	PRT	PRINT THE LINE
	BCS 	ELINE	UNCONDITIONAL

TRYREP	CMP 	#$25	IS IT '%' REQUEST TO PAD A LINE?
	BNE 	CHAR

**** PAD THE LINE FROM CURRENT LOC TO EOL WITH DELETE CHAR

PADLOP	LDAA	(CURAD),Y	GET CURRENT CHARACTER
	BEQ SETNL	IF ZERO, WE ARE DONE
	LDAA	#$80	ELSE MAKE IT A DELETE CHAR (was $ff -DHH)
	STA (CURAD),Y
	INY		BUMP TO NEXT CHARACTER
	BPL PADLOP	LOOP IF HAVEN'T DONE 128
	DEY		LINE IS TOO LONG - BACK UP ONE
	LDAA	#CR		FORCE AN EOL HERE

**** IT WASN'T AN EDIT CHARACTER - MUST BE DATA TO SAVE

CHAR	CMP #CR		IS IT CARRIAGE RETURN AS EOL?
	BNE CHAR1	SKIP AHEAD IF NOT
	LDAA	#$00	ELSE CONVERT CR TO 00 AS EOL
CHAR1	STA (CURAD),Y	PUT IT AWAY
	BEQ SETNL	BRANCH IF YES
	INY		ELSE BUMP TO SET UP FOR NEXT ONE
	BPL EGET	AND GO GET IT IF STILL ROOM ON LINE
	DEY		ELSE POINT BACK TO LAST CHAR & FALL THRU

SETNL	JSR LINEND	DO CR/LF AND FIX UP CURAD
	BCS ELINE	GO START A NEW LINE

**** EXECUTION PORTION STARTS HERE

EXEC	JSR SAVCR	EXTRA BLANK LINE AFTER EDITOR
RESTRT	JSR SETBGN	HERE IF FROM J:*
	LDX #$33	ZERO VARIABLE AREAS
	LDAA	#$00
	STA RETURN+1	
RESTR1	STA VARIBS,X
	DEX
	BPL RESTR1

LSTART	LDAA	(CURAD),Y	GET CHARACTER FROM THE LINE
	CMP #$2A	CHECK FOR '*' LABEL MARKER
	BNE CHKCON	IF NOT - GO CHECK FOR CONDITIONAL
	INY		OTHERWISE SKIP PAST THE '*'
SKPNXT	INY		SKIP PAST THE NEXT CHARACTER
	BNE LSTART	UNCONDITIONAL

**** FLAG DEPENDENT PROCESSING HERE

CHKCON	CMP #$59	CHECK FOR 'Y' REQUEST
	BEQ TFLAG	BRANCH IF YES
	CMP #$4E	IF NOT - CHECK FOR 'N' REQUEST
	BNE STRTST	BRANCH IF NEITHER

**** SEE IF CONDITIONAL MATCHES FLAG

TFLAG	CMP FLG	SEE IF THEY MATCH
	BEQ SKPNXT	SKIP TO NEXT CHAR AND EXECUTE LINE

**** NO MATCH - SKIP THIS STATEMENT

FWD	JSR FWD1	USE THIS SUBROUTINE
	BCS LSTART	UNCONDITIONAL

STRTST	JMP EXTRA	head to Bob's and my extra statements --DHH
	NOP

**** ORIGINAL CODE (Bob echoes this):
;STRTST	STA IFLAG	THIS WILL CLEAR HIGH BIT FOR EDITOR
;	INY		POINT TO THE ':' CHAR
;	INY		AND TO THE FOLLOWING CHARACTER

**** ENTER NAME STATEMENT

XQUEST	CMP #$3F	IS IT '?' FOR ENTER NAME?
	BNE XA		BRANCH IF NOT
	SEC		TURN HIGH BIT ORDER ON TO INDICATE
	ROR IFLAG	PROCESSING NAME COMMAND
	BNE TAKEIN	NOW USE THE ACCEPT LOGIC

**** ACCEPT STATEMENT

XA	CMP #$41	SEE IF WE HAVE AN ACCEPT STATEMENT
	BNE XC		BRANCH IF NOT
	LDAA	CURAD	SAVE ADDRESS OF THE 'A' STATEMENT
	STA LST		NOTE: WILL INCLUDE CONDITIONALS
	LDAA	CURAD+1	
	STA LST+1	

TAKEIN	LDAA	#$3F	DISPLAY '?' PROMPTING CHARACTER
	JSR OUTCH

	LDX #$27	CHRS GET STORED BACKWARD
ACHR	JSR INCH	GET AN INPUT CHARACTER
	CMP #$08	IS IT A BACKSPACE?
	BNE ACHR1	BRANCH IF NOT
	INX		ELSE FORGET ABOUT LAST CHARACTER
	BNE ACHR	UNCONDITIONAL
ACHR1	CMP #CR		WAS IT A CARRIAGE RETURN?
	BNE ACHR2	NO - SKIP AHEAD
	LDAA	#$00	YES - CONVERT CR TO EOL
ACHR2	STA CHRS,X	AND SAVE IT FOR MATCH STATEMENT
	BIT IFLAG	SEE IF GETTING NAME FIELD
	BPL ACHR3	BRANCH IF NOT
	STA NAME,X	ELSE SAVE IN NAME FIELD ALSO
ACHR3	CMP #$00	IS IT DONE YET?
	BEQ ADONE	BRANCH IF HE HAS SIGNALED END
	DEX		ELSE BUMP FOR NEXT INPUT
	BPL ACHR	AND GO GET IT IF ROOM STILL LEFT
ADONE	JSR SAVCR	DO A CR/LF TO LET GUY KNOW
	JMP FWD

**** COMPUTE STATEMENT

XC	CMP #$43	IS IT 'C' FOR COMPUTE?
	BEQ XC1		BRANCH IF IT IS
	JMP XM		ELSE LONG JUMP TO TEST FOR 'M'
XC1	JSR GETIDX	GET INDEX POINTER TO RESULT
	STX ANSX	SAVE IT FOR NOW
	LDAA	#$00	CLEAR RESULT
	STA RESULT
	STA RESULT+1	
	INY		POINT TO '='
	LDX #$2B	SET 1ST OPERATION TO '+' FOR ADD
	BNE OPWRAP	GO SAVE AND SET UP WORK AREA

**** LOOP FOR EACH NEW CHARACTER IN COMPUTE PROCESS

CMPLOP	INY		BUMP TO NEXT CHARACTER
	LDAA	(CURAD),Y	GET A CHARACTER
	BMI ISOPR	MINUS IS DELETE/ALSO LAST 'OPERATOR'
	CMP #$2F	IS IT < '/' FOR AN OPERATION SPECIFIED?
	BCC ISOPR	BRANCH IF YES
	CMP #$3A	IF NOT - IS IT > ':' FOR not A NUMBER?
	BCS NOTNMB	BRANCH IF NOT - MUST BE A VARIABLE

	AND #$0F	CONVERT NUMBER TO BINARY
	ROR		SPIN TO HIGH ORDER PART OF A
	ROR
	ROR
	ROR		LEAVE BIT 3 IN CARRY
	LDX #$04	4 BITS TO ROLL INTO WORK
BITROL	ROL WORK+1	RIPPLE CARRY INTO WORK
	ROL WORK	FOR 16 BITS
	ASL		PUT NEXT BIT INTO CARRY
	DEX		COUNT ONE JUST DONE
	BNE BITROL	CONTINUE IF MORE TO GO
	BEQ CMPLOP	ELSE GET NEXT CHARACTER (DIGITS)

NOTNMB	JSR VTRANS	TRANSFER VARIABLE TO WORK AREA
	JMP CMPLOP	GO GET NEXT CHARACTER (OPERATION?)

**** GOT AN OPERATION - FIRST PERFORM PREVIOUS REQUEST

ISOPR	SED		SET TO DECIMAL MODE
	TAX		SAVE NEW OPERATION IN X FOR NOW
	LDAA	OPRATN	GET PREVIOUS OPERATION
	CMP #$2D	WAS IT A '-' FOR SUBTRACT?
	BEQ OPMNUS	BRANCH IF YES
	CLC		ALL OTHERS ASSUME IT IS ADD
	LDAA	WORK+1
	ADC RESULT+1
	STA RESULT+1
	LDAA	WORK
	ADC RESULT
	STA RESULT
	JMP OPWRAP	GO WRAP UP THE OPERATION

OPMNUS	SEC		SUBTRACTION
	LDAA	RESULT+1
	SBC WORK+1
	STA RESULT+1
	LDAA	RESULT
	SBC WORK
	STA RESULT

OPWRAP	CLD		GET OUT OF DECIMAL MODE
	STX OPRATN	SAVE NEW OPERATION
	TXA		DO TRANSFER TO CHECK FOR '00'/'FF'
	BEQ CMPDON	DONE IF IT WAS ZERO (EOL)
	BMI CMPDON	OR DELETE CHARACTERS (FROM FILLING)

	LDAA	#$00	ELSE CLEAR WORK AREA FOR NEXT ONE
	STA WORK
	STA WORK+1
	BEQ CMPLOP	AND GO DO NEXT CHARACTER

CMPDON	LDX ANSX	GET INDEX TO RESULT
	BPL TOVRIB	PLUS IS NORMAL INDEX TO A VARIABLE
	
	LDX #$38	ELSE FUDGE INDEX FOR 'FROM' RESULT
			USING 'RESULT - VARIBS'
	JSR VTRANS+3	MOVE RESULT TO WORK AREA
	JSR CNVDSP+3	CONVERT IT TO DISPLAY FORM
	LDX #$04	TRANSFER DISPLAY TO NUMBER AREA
TALOOP	LDAA	NUMDSP,X
	STA CHRS+35,X	NOTE OFFSET TO PUT IT AT THE END
	DEX		(was '23' in orig. source, no '$'
	BPL TALOOP	          to denote hex no. -DHH)
	BMI XFWD	UNCONDITIONAL
TOVRIB	LDAA	RESULT+1	DESIRED VARIABLE
	STA VARIBS+1,X
	LDAA	RESULT
	STA VARIBS,X
XFWD	JMP FWD		AND GO DO THE NEXT ONE

**** PROCESS MATCH STATEMENT

XM	CMP #$4D	IS IT 'M' FOR MATCH?
	BNE XU		BRANCH IF NOT
MDEY	DEY		BACK UP ONE FOR WHAT FOLLOWS
MCHKX	INY		POINT TO MATCH CHARACTER
	LDX #$27	START AT FIRST ACCEPTED CHARACTER
MCHK	LDAA	(CURAD),Y	GET THE MATCH CHARACTER
	BEQ MXY		THEY HAVE MATCHED TO END OF 'M:' STMT
	CMP CHRS,X	CHECK FOR MATCH
	BNE MXNMCH	BRANCH IF MATCH FAILED
	INY		ELSE BUMP TO NEXT PAIR OF CHARACTERS
	DEX
	BPL MCHK	AND GO CHECK IF STILL DATA LEFT
MXY	LDX #$59	BOTH EQUAL - SET FLAG TO 'Y'
	BNE MX		UNCONDITIONAL
MXNMCH	CMP #$24	IS IT '$' FOR VARIABLE REQUEST?
	BEQ MNUMB	YES - MATCH TO NUMERIC VARIABLE
	CMP #$2C	IS IT A COMMA GROUP SEPARATOR?
	BEQ MXY		YES - MATCHED SO FAR - SET IT AS YES

MCOMMA	INY		NO - SO NEED TO SKIP AHEAD TO COMMA
	LDAA	(CURAD),Y
	BEQ MXSETN	IF TO EOL, THERE IS NO MORE TO CHECK
	CMP #$2C	IS IT A COMMA CHARACTER?
	BEQ MCHKX	RESTART COMPARE AT NEXT MATCH CHARACTER
	BNE MCOMMA	LOOP IN SEARCH OF A COMMA
MCOMX	LDY HOLDY	RESET Y TO CURRENT LINE POINTER
	BNE MCOMMA	AND GO LOOK FOR NEXT COMMA

MNUMB	INY		VARIABLE - BUMP TO VARIABLE ID
	STX ANSX	SAVE CURRENT X FOR NOW
	JSR CNVDSP	CONVERT VARIABLE TO DISPLAY FORM
	LDX ANSX	GET POINTER TO INPUT BACK
	STY HOLDY	HOLD CURRENT 'Y' POINTER
	LDY #$04	HAVE TO SEARCH UP TO 5 BYTES

MXNOLP	LDAA	NUMDSP,Y	GET ONE NUMERIC CHARACTER
	BEQ MXDIFF	BRANCH IF END - MIGHT BE MATCH
	CMP CHRS,X	ELSE CHECK AGAINST INPUT
	BNE MCOMX	BRANCH IF NO MATCH
	DEX		ELSE CONTINUE MATCHING
	DEY
	BPL MXNOLP	UNCONDITIONAL

MXDIFF	LDY HOLDY	RESET Y TO CURRENT LINE POINTER
	INY		BUMP TO CHARACTER AFTER VARIABLE
	BNE MCHK	UNCONDITIONAL CONTINUE CHECKING

MXSETN	LDX #$4E	GET 'N' - MATCH WAS UNSUCCESSFUL
MX	STX FLG		STORE IT
	BNE XFWD	UNCONDITIONAL FORWARD TO NEXT LINE

**** PROCESS USE SUBROUTINE STATEMENT

XU	CMP #$55	IS IT A 'U' FOR USE SUBROUTINE?
	BNE XJ		BRANCH IF NOT
	LDAA	(CURAD),Y	GET DESTINATION
	PHA		SAVE THE LABEL CHARACTER
	JSR FWD1	MOVE TO START OF NEXT LINE
	LDAA	CURAD
	STA RETURN	SAVE FOR RETURN ADDRESS
	LDAA	CURAD+1
	STA RETURN+1
	PLA		GET DESTINATION BACK
	BNE JDO		NO GO HANDLE AS JUMP STATEMENT

**** PROCESS JUMP STATEMENT

XJ	CMP #$4A	IS IT 'J' FOR MATCH STATEMENT?
	BNE XS		BRANCH IF NOT
	LDAA	(CURAD),Y	GET DESTINATION

JDO	STA IFLAG	SAVE LABEL CHARACTER
	CMP #$2A	HAVE '*' TO REQUEST RETURN TO BEGINNING?
	BEQ IREST	BRANCH IF SO
	CMP #$41	SEE IF A LABELED JUMP
	BNE JF		IF NOT 'A', IT'S A NORMAL JUMP

	LDAA	LST		ELSE SET TO START OF LAST ACCEPT
	STA CURAD
	LDAA	LST+1
	STA CURAD+1
	BNE ILNEXT	UNCONDITIONAL

JF	JSR SETBGN+3	AND GET BACK TO START OF PROGRAM

FNDMRK	LDAA	(CURAD),Y	GET FIRST CHARACTER
	CMP #$2A	IS IT '*' FOR A MARKER?
	BNE FMNEXT	NOPE - GO AHEAD TO NEXT LINE
	INY		ELSE BUMP TO MARKER CHARACTER
	LDAA	(CURAD),Y	GET LABEL
	CMP IFLAG	SEE IF IT'S THE ONE WE WANT
	BEQ ILNEXT	YES - GO EXECUTE IT
FMNEXT	JSR FWD1	ELSE GO TO NEXT LINE
	BCS FNDMRK	AND CONTINUE LOOKING
IREST	JMP RESTRT	INDIRECT TO RESTRT

**** STOP STATEMENT

XS	CMP #$53	IS IT AN 'S' FOR STOP STATEMENT?
	BNE XE		BRANCH IF NOT
	JMP START	ELSE RETURN TO EDITOR START

**** EXIT FROM SUBROUTINE

XE	CMP #$45	IS IT AN 'E'?
	BNE XR		BRANCH IF NOT
	LDAA	RETURN+1	MOVE RETURN ADDRESS TO CURAD
	BEQ XXFWD	SKIP LINE IF NOT SET
	STA CURAD+1
	LDAA	RETURN
	STA CURAD
	LDAA	#$00	NOW SET TO NOT USED AGAIN
	STA RETURN+1
	BEQ ILNEXT	UNCONDITIONAL

**** REMARK STATEMENT

XR	CMP #$52	IS IT AN 'R'?
	BNE XT		BRANCH IF NOT - ELSE SKIP THE LINE
XXFWD	JMP FWD		CAN'T BRANCH THAT FAR ALONE

**** TYPE STATEMENTS AND SYNTAX ERRORS

XT	CMP #$54	IS IT A VALID 'T' STATEMENT?
	BEQ TE		BRANCH IF SO
	DEY		ELSE BACK UP TO ORIGINAL START
	DEY
TE	JSR PRT		NOW PRINT THE LINE
ILNEXT	JSR SKPJNK	CURAD IS SET - SKIP OVER LEADING JUNK
	JMP LSTART	AND GO START ON THE LINE

**** PRINT A LINE FROM CURRENT LOCATION TO
**** NEXT EOL AND THEN SET UP FOR NEXT LINE

PRT	LDAA	(CURAD),Y	GET THE CURRENT CHARACTER
	BEQ LINEND	BRANCH IF TO END OF LINE
	BIT IFLAG	SEE IF IN EDITOR
	BMI CHROUT	IF SO, DON'T LOOK FOR '$'

	CMP #$24	IS IT A SPECIAL ONE ('$')?
	BNE CHROUT	BRANCH IF NOT
	INY		ELSE BUMP TO NEXT ONE
	LDAA	(CURAD),Y	GET VARIABLE
	CMP #$3F	IS IT REQUEST FOR NAME ('?')?
			NV source in MICRO shows a ('$') in
			the comment column, but $3F is in the
			hex dump and the assembly listing. --DHH
	BEQ NAMEO	BRANCH IF YES
	JSR CNVDSP	CONVERT VARIABLE TO DISPLAY
	LDX #$04	GOT 5 BYTES POSSIBLE

VBDISP	LDAA	NUMDSP,X	GET A CHARACTER
	BEQ CHROUT+3	BRANCH IF TO END OF VARIABLE
	JSR OUTCH	ELSE OUTPUT IT
	DEX		AND COUNT IT
	BPL VBDISP	UNCONDITIONAL LOOP

NAMEO	LDX #$27	REMEMBER - IT CAME IN BACKWARDS
	LDAA	NAME,X
	BEQ CHROUT+3	BRANCH IF TO END OF NAME
	JSR OUTCH
	DEX
	BPL NAMEO+2	UNCONDITIONAL

CHROUT	JSR OUTCH
	INY
	BPL PRT		LOOP IF NOT TOO MANY
	BMI SETBGN	RESET TO BEGINNING IF PAST THE END
LINEND	JSR SAVCR	OUTPUT CR AND LF

**** ENTER HERE TO SKIP A LINE WITHOUT PRINT
**** AND INITIALIZE FOR THE NEXT LINE

FWD1	LDAA	(CURAD),Y	GET A CHARACTER
	BEQ SCURAD	BRANCH IF END OF LINE
	INY		ELSE BUMP TO NEXT ONE
	BPL FWD1	LOOP IF NOT TOO MANY
	BMI SETBGN	RESET TO BEGINNING IF PAST THE END

**** HERE FIXES UP CURAD TO POINT TO BEGINNING OF A LINE
**** CURAD SHOULD INDEX END OF LINE (WITH Y) ON ENTRY

SCURAD	INY		BUMP PAST THE CR
	TYA		MOVE COUNT TO A
	CLC		CLEAR CARRY FOR ADD
	ADC CURAD	ADD TO LOW ORDER FIRST
	STA CURAD	AND SAVE RESULT
	BCC SKPJNK	SKIP IF NO CARRY FORWARD
	INC CURAD+1	ELSE BUMP HIGH ORDER

**** HERE TO SKIP PAST LEADING JUNK ON A LINE

SKPJNK	LDY #$FF	SET UP Y THIS WAY
SJLOOP	INY		INCREMENT TO NEXT CHARACTER
	BIT IFLAG	SEE IF IN EDIT MODE
	BMI SJRTS	DON'T TRY SKIPPING JUNK IF SO
	LDAA	(CURAD),Y	GET CHARACTER TO LOOK AT
	BMI SJLOOP	IGNORE DELETE CHARACTER ALSO
	CMP #$2A	LOOK FOR '*' LABEL MARKER
	BEQ SJRTS	RETURN IF FOUND
	CMP #$3F	LOOK FOR POSSIBLE OPERATION CHARACTER
	BCC SJLOOP	CONTINUE SKIPPING IF TOO LOW
SJRTS	SEC		SET CARRY FOR BRANCHES AFTER RETURN
	RTS		AND BEFORE RETURN

**** SET UP BEGINNING ADDRESS OF USER AREA

SETBGN	JSR SAVCR	START ON A NEW LINE
	LDY #$00	EVEN PAGE BOUNDARY
	STY CURAD
	STY LST		ALSO SET UP THIS GUY AS DEFAULT
	LDAA	#$06	was $05. Changed to add room for 
	STA CURAD+1	all the extensions ---DHH
	STA LST+1
	BNE SKPJNK	UNCONDITIONAL

**** COMPUTE INDEX FOR A VARIABLE

GETIDX	LDAA	(CURAD),Y	GET VARIABLE LETTER
	SEC
	SBC #$41	SUBTRACT 'A' TO MAKE RELATIVE TO ZERO
	ASL		TIMES TWO BYTES PER VARIABLE
	TAX		MOVE TO INDEX REGISTER
	RTS		AND RETURN

**** TRANSFER A VARIABLE'S DATA TO WORK AREA

VTRANS	JSR GETIDX	GET INDEX POINTER FIRST
	LDAA	VARIBS+1,X	NOW MOVE TO WORK AREA
	STA WORK+1
	LDAA	VARIBS,X
	STA WORK
	RTS

**** CONVERT A VARIABLE TO DISPLAY FORM

CNVDSP	JSR VTRANS	MOVE TO WORK AREA
	BPL ISPLUS	BRANCH IF POSITIVE
	LDAA	#$2D	ELSE PUT IN MINUS SIGN
	STA NUMDSP+4
	SED		SET DECIMAL MODE INDICATOR
	SEC
	LDAA	#$00	SUBTRACT FROM ZERO TO COMPLIMENT

	SBC WORK+1
	STA WORK+1
	LDAA	#$00
	SBC WORK
	STA WORK
	CLD		CLEAR DECIMAL MODE
	LDX #$03	ONLY 4 POSITIONS LEFT
	BNE ISPL1	SKIP INDEX SET (orig source has BNE ISPL
			but hex dump shows a branch of 02 --DHH)

ISPLUS	LDX #$04	PLUS HAS FIVE POSITIONS AVAILABLE
ISPL1	CLC		TURN OFF SIGNIFICANCE INDICATOR
	ROR SIGNIF
	LDAA	WORK	GET FIRST DIGIT
	JSR TOOUT	PUT TO OUTPUT AREA
	LDAA	WORK+1	SECOND DIGIT IS HIGH ORDER OF THIS
	LSR
	LSR
	LSR
	LSR
	JSR TOOUT
	LDAA	WORK+1	LOW ORDER IS THIRD DIGIT
	JSR TOOUT
	BIT SIGNIF	SEE IF IT HAD ANY SIGNIFICANT CHARS
	BMI ISPL2	SKIP NEXT IF YES
	DEX		ELSE KEEP THE LAST ZERO THERE
ISPL2	LDAA	#$00	INSERT END OF LINE MARKER
	STA NUMDSP,X
	RTS		AND RETURN

**** CONVERT CURRENT VALUE TO ASCII AND PUT TO OUTPUT AREA

TOOUT	AND #$0F	KEEP ONLY LOW ORDER
	ORA #$30	MAKE IT ASCII
	STA NUMDSP,X	SAVE REGARDLESS
	BIT SIGNIF	SEE IF SIGNIFICANCE STARTED
	BMI SETSIG	YES - ALL ARE IMPORTANT NOW
	CMP #$30	ELSE SEE IF SHOULD START NOW
	BNE SETSIG	IMPORTANT IF NOT ZERO
	RTS		ELSE RETURN

SETSIG	SEC		SET SIGNIFICANCE BIT ON
	ROR SIGNIF	ALWAYS
	DEX		AND POINT TO NEXT AVAILABLE POINTER
PGMEND	RTS		AND THEN RETURN

**** Bob Applegate's KIM-1 specific IN/OUT/CRLF routines
**** 6800: only CRLF needed for HM-68

SAVCR	LDAA	#$0A
	JSR	OUTCH
	LDAA	#$0D
	JSR	OUTCH
	RTS

**** New Tiny PILOT commands added by Bob Applegate.
**** Appeared in MICRO, Aug. 1980, issue 27, pg. 21
**** 
**** I:x -- Input a positive number into any variable x
**** P:x -- Puts a random number 0-99 into variable x
**** L:x -- Call ML subroutine loc in variable x. Starting
            addr of variable to be PRE-STORED as:
;		NAME	Zero Pg Addrs
;		A	$A0, $A1
;		B	$A2, $A3
;		C	$A4, $A5
		    . . . . .
;		Y	$D0, $D1
;		Z	$D2, $D3

EXTRA	STA IFLAG	clear high bit for editor -- BA
	INY		point to ':'
	INY		and the next character

**** CALL ML SUBROUTINE STATEMENT
**** Modified by DHH to remove self-modifying code.

	CMP #$4C	is it the L command
	BNE XP		no, go to P command
XL	JSR GETIDX	compute the index
	LDAA	$A0,X	get the low-order byte from table
	STA STORX	and store in a temp loc.
	LDAA	$A1,X	get the high-order byte
	STA STORY	and store in ajacent temp loc.
	STY HOLDY	necessary, X too?
STRSUB	JSR GOL		subroutine will return here
	LDY HOLDY
	JMP FWD		all done, return to PILOT
GOL	JMP (STORX)	indirect jump to ML program

**** GENERATE RANDOM NUMBER STATEMENT

XP	CMP #$50	is it the P command
	BNE XI		nope, go to I command
	JSR GETIDX	compute the index
	STX ANSX	store the index for now
*			following is a slightly modified
*			version of Jim Butterfield's random
*			number routine from FBOK, pg. 172.
	SED		decimal numbers only, please
	SEC		carry adds value 1
	LDAA	$D5		last value
	ADC $D8		add B + carry
	ADC $D9		add C
	STA $D4		new random number
	LDX #$04	move 5 numbers
XPLOOP	LDAA	$D4,X	get first number
	STA $D5,X	move over 1
	DEX		next number
	BPL XPLOOP	all moved?
	CLD		everything back to normal
	LDX ANSX	pick up the index
	STA VARIBS+1,X	store the number at variable
			(should this be just VARIBS? --DHH)
	JMP FWD		back to PILOT

**** INPUT A POSITIVE NUMBER STATEMENT

XI	CMP #$49	see if it's the I command
	BNE XZ		go to Z command
	LDAA	#$3F	get a '?'
	JSR OUTCH	output it as a prompt
	LDAA	#$00	clear things out
	STA $DA		especially this temp variable
	STA $DB		ditto
XIINPT	JSR INCH	get input
	CMP #CR		cr?
	BEQ XINDX	yes, branch to get index
	SEC		get ready to subtract
	SBC #$30	turn ASCII into BCD
	LDX #$04	get ready to multiply by 10
XILOOP	CLC		clear things first ('CMC' mnemonic in source)
	ASL $DB		multiply
	ROL $DA		multiply
	DEX		again?
	BNE XILOOP	yes, then loop
	CLC		clear things up again
	ADC $DB		add the new digit
	STA $DB		store the answer
	JMP XIINPT	do it all over again
XINDX	JSR GETIDX	get the index
	LDAA	$DA		get first part of answer
	STA VARIBS,X	store it at variable
	LDAA	$DB		get the next part
	STA VARIBS+1,X	and store that
	JSR SAVCR	start a new line
	JMP FWD		all done, return to PILOT

**** ZAP statement by Dave Hassler, 2023.  Clears all
**** variables except Bob's and all user RAM
**** for that fresh, power-up feeling. 'Cleans' registers, too!
**** (i.e., X,Y affected). The equivalent of BASIC's 'NEW'
**** command.

XZ	CMP #$5A	see if it's the Z statement
	BNE JUMPXD	go to JMP for D: statement
	CLD
			first, Zero Pg
	LDX #$00
	LDAA	#$00
ZLOOP	STA $00,X	store '00'
	INX
	CPX #$87	not past this loc.
	BNE ZLOOP
	
	LDY #$00	next, user memory
	STY STORX
	LDAA	#$06	first page to '00'
	STA STORY
MLOOP	LDAA	#$00
	STA (STORX),Y	store '00's - the EOL marker
	INY
	BNE MLOOP	until Y rolls over
	INC STORY	when it does, +1
	LDAA	STORY	the page #
	CMP #$14	is it now Page $14?
	BNE MLOOP	no, go fill it with '00'

	LDAA	#$00	clear processor flags
	STA $F1
	JMP START	jump back to START

JUMPXD	JMP XX		JMP to XD

**** OUTPUT A WELCOME BANNER BEFORE EXECUTION (DHH)

WELCOM	JSR SAVCR		CRLF
	LDX #$00		print header
PRNT2	LDAA	TITLE,X
	BEQ WELDUN		go start TP proper
	JSR OUTCH		call out to TTY routine
	INX
	JMP PRNT2
WELDUN	RTS

TITLE
.BYTE	$0A $0D
.BYTE	"6800 Tiny PILOT"
.BYTE	$0A $0D $00
.BYTE	"6502 orig Nicholas Vrtis 1979. 6800 vers Dave Hassler 2024."


**** X: Statement (swap/transfer NAME and STRING) -- DHH

* = $1780

XX	CMP #$58	see if it's the X: statement
	BNE GOBACK	no, head back
	STY STORY
	LDY #$27	will go 40 times/chars
XXLOOP	LDAA	NAME,Y
	LDX STRING,Y
	STA STRING,Y
	STX NAME,Y
	DEY
	BNE XXLOOP
	LDY STORY
	JMP FWD

GOBACK	JMP XQUEST	not a new command, check old ones
