*
*	*******************************
*	*                             *
*	*     T i n y   P I L O T     *
*	*          for 6800           *
*	*                             *
*	*    Original 6502 version    *
*	*      by Nicholas Vrtis      *
*	*             in              *
*	*   MICRO, iss. 16, pg. 41    *
*	*       September, 1979       *
*	*                             *
*	*   Modified for 6800/2 and   *
*	*   HM-68 homemade computer   *
*	*       by Dave Hassler       *
*	*       February, 2024        *
*	*                             *
*	*    This version is v 2.2    *
*	*                             *
*	*******************************
*
*    With 6502 I, P, and L statement additions by Bob Applegate, 1980. 
*    X statement; plus 6800 rewrites to C, L, and P statements;
* new Zap and Quit commands; and title by Dave Hassler, 2024.
*    NV's original comments in upper case (mine usually l/c with DHH).
*
*    This ported 6800 assembly code of Tiny PILOT, with the exception of 
* Nicholas Vrtis' comments, is copyright (c) 2024 David H. Hassler, 
* and is released under the MIT licence.  See the full text of the license
* at https://mit-license.org/
*
*    Assemble with AS0 Motorola 6800 Assembler,
*    updated to ANSI-standard C by Jim Newman.
*    (found at: https://github.com/JimInCA/motorola-6800-assembler)
*    Linux: ./as0 TINYPILOT6800b.ASM -l >> tinypilot6800b.lst
*    A Motorola S-Record and a full listing file will be output.

**** PAGE ZERO REFERENCES

LST	EQU	$00
FLG	EQU	$02
CHRS	EQU	$03
NAME	EQU	$2B
VARIBS	EQU	$53
IFLAG	EQU	$87
HOLDY	EQU	$88
WORK	EQU	$89
RESULT	EQU	$8B
WORK2	EQU	$BD
OPRATN	EQU	$8F
NUMDSP	EQU	$90
RETURN	EQU	$95
CURAD	EQU	$97
ANSX	EQU	$99
SIGNIF	EQU	$9A
STRING	EQU	$A6

* Uses $A0-$A5 for Bob's ML call variables, if the user
* sets up for the L: statement (variables A-C).
* STRING runs from $A6 to $CD --DHH 

CURAD2	EQU	$DA	2 bytes
RANDUM	EQU	$DC	2 bytes
BOB1	EQU	$DE
BOB2	EQU	$DF
NTEMPA	EQU	$E0
NTEMPB	EQU	$E2
NTEMPX	EQU	$E4	2 bytes
NTEMPY	EQU	$E6
NTEMPOF	EQU	$E8
NTEMPZ	EQU	$EA	2 bytes

STORA	EQU	$EC	next 3 hold what were 6502 registers, as needed
STORX	EQU	$ED
STORY	EQU	$EF
OFFSET	EQU	$F0	<-- this used for 6502 index X --DHH
STORB	EQU	$F2	temps
STORZ	EQU	$F4

CR	EQU	$0D		

**** EXTERNAL ADDRESS REFERENCES
**** These are for SWTBUG/MIKBUG (scratch RAM in HM-68 is $7F00)

CONTROL	EQU	$E0E3	RETURN TO SWTBUG PROMPT - CONTRL
OUTCH	EQU	$E1D1	OUTPUT CHAR ON CONSOLE
INCH	EQU	$E1AC	INPUT CHAR FROM CONSOLE AND ECHO
PDATA1	EQU	$E07E	PRINT TEXT STRING @ X ENDED BY $04
OUT2HS	EQU	$E0CA	PRINT 2 HEX CHARS @ X
OUT4HS	EQU	$E0C8	PRINT 4 HEX CHARS @ X
INBYTE	EQU	$E055	INPUT 1 BYTE TO A.


	ORG $0100

**** PRINT TITLE

	JSR WELCOM	go print a welcome line --DHH

**** START OF EDITOR PORTION

START	LDAA	#$80	SET MODE TO EDIT FOR PRT ROUTINE
	STAA	IFLAG
	JSR	SETBGN	SET UP STARTING DATA AREA ADDRESS

**** HERE IS THE START OF EACH NEW LINE

ELINE	LDAA	#$3E	OUTPUT A '>' PROMPT CHARACTER
	JSR 	OUTCH

**** HERE IS WHERE EACH INPUT CHARACTER IS OBTAINED

EGET	JSR 	INCH	INPUT A CHARACTER FROM USER
	STAA	STORA	CHECK FOR NULLS AND IGNORE
	BEQ 	EGET	SO THEY DON'T GET CONFUSED WITH EOL

	CMPA 	#$5E	IS IT '^'?
	BEQ 	START	YES - START AT BEGINNING AGAIN

	CMPA	#$7E	is it '~'?
	BNE	IS_EXIT	no, try _
	JMP	ZAPRAM	yes, go do it

IS_EXIT	CMPA	#$5F	is it '_' for quit PILOT?
	BNE	IS_AT	no, try @
	LDX	#EXITMSG	load exit message
	JSR	PDATA1	print it
	LDX	CURAD2	get current end of user script
	INX		pad to get past final 'S' colon and EOR
	INX
	STX	CURAD2
	LDX	#CURAD2
	JSR	OUT4HS	print that address
	JSR	SAVCR	crlf
	JMP	CONTROL	exit, jump back to SWTBUG

IS_AT	CMPA	#$40	IS IT '@' FOR EXECUTE REQUEST?
	BNE	IS_BS	no, so is it backspace?
	CLR	STORY	set 'Y' to 0 for indir-index
	BRA	EXEC	YES, GO START ON THAT

IS_BS	CMPA	#$08	IS IT A BACKSPACE?
	BNE	TRYDSP	NO - GO CHECK FOR DISPLAY REQUEST
	DEC	STORY	YES - BACK UP ONE CHARACTER
	BPL 	EGET	BUT CHECK FOR PAST START OF LINE
	INC	STORY	BACKED UP TOO FAR - DISALLOW
	BPL 	EGET	UNCONDITIONAL

TRYDSP	CMPA 	#$5C	IS IT '\' FOR DISPLAY LINE REQUEST?
	BNE 	TRYREP	NO - CHECK FOR REPLACEMENT REQUEST

**** DISPLAY TO THE NEXT CARRIAGE RETURN

	JSR 	PRT	PRINT THE LINE
	BCS 	ELINE	UNCONDITIONAL

TRYREP	CMPA 	#$25	IS IT '%' REQUEST TO PAD A LINE?
	BNE 	CHAR

**** PAD THE LINE FROM CURRENT LOC TO EOL WITH DELETE CHAR

PADLOP	LDAA	STORY	get the offset -DHH
	JSR	IND_Y	call the indirect-indexed-Y routine
	LDAA	0,X	GET CURRENT CHARACTER
	BEQ	SETNL	IF ZERO, WE ARE DONE
	LDAA	#$80	ELSE MAKE IT A DELETE CHAR (was $ff -DHH)
	STAA	0,X
	INC	STORY	BUMP TO NEXT CHARACTER
	BPL	PADLOP	LOOP IF HAVEN'T DONE 128
	DEC	STORY	LINE IS TOO LONG - BACK UP ONE
	LDAA	#CR	FORCE AN EOL HERE

**** IT WASN'T AN EDIT CHARACTER - MUST BE DATA TO SAVE

CHAR	CMPA	#CR	IS IT CARRIAGE RETURN AS EOL?
	BNE	CHAR1	SKIP AHEAD IF NOT
	LDAA	#$00	ELSE CONVERT CR TO 00 AS EOL
CHAR1	TAB		store A in B
	LDAA	STORY	get the offset -DHH
	JSR	IND_Y	call the indirect-indexed-Y routine
	TBA		get A back
	STAA	0,X	PUT IT AWAY
	BEQ	SETNL	BRANCH IF YES
	INC	STORY	ELSE BUMP TO SET UP FOR NEXT ONE
	BPL	EGET	AND GO GET IT IF STILL ROOM ON LINE
	DEC	STORY	ELSE POINT BACK TO LAST CHAR & FALL THRU

SETNL	JSR	LINEND	DO CR/LF AND FIX UP CURAD
	JMP	ELINE	GO START A NEW LINE

**** EXECUTION PORTION STARTS HERE

EXEC	JSR	SAVCR	EXTRA BLANK LINE AFTER EDITOR
RESTRT	JSR	SETBGN	HERE IF FROM J:*

	CLR	RETURN+1
	LDX	#VARIBS+$33
RESTR1	CLR	0,X
	DEX
	CPX	#VARIBS-1
	BNE	RESTR1

LSTART	LDAA	STORY	get the offset
	JSR	IND_Y	call the indirect-indexed-Y routine
	LDAA	0,X
	CMPA	#$2A	CHECK FOR '*' LABEL MARKER
	BNE	CHKCON	IF NOT - GO CHECK FOR CONDITIONAL
	INC	STORY	OTHERWISE SKIP PAST THE '*'
SKPNXT	INC	STORY	SKIP PAST THE NEXT CHARACTER
	BNE	LSTART	UNCONDITIONAL

**** FLAG DEPENDENT PROCESSING HERE

CHKCON	CMPA	#$59	CHECK FOR 'Y' REQUEST
	BEQ	TFLAG	BRANCH IF YES
	CMPA	#$4E	IF NOT - CHECK FOR 'N' REQUEST
	BNE	STRTST	BRANCH IF NEITHER

**** SEE IF CONDITIONAL MATCHES FLAG

TFLAG	CMPA	FLG	SEE IF THEY MATCH
	BEQ	SKPNXT	SKIP TO NEXT CHAR AND EXECUTE LINE

**** NO MATCH - SKIP THIS STATEMENT

FWD	JSR	FWD1	USE THIS SUBROUTINE
	BRA	LSTART	UNCONDITIONAL

STRTST	JMP	EXTRA	head to Bob's and my extra statements --dhh
	NOP

**** ORIGINAL CODE (Bob echoes this):
*STRTST	STAA IFLAG	THIS WILL CLEAR HIGH BIT FOR EDITOR
*	INY		POINT TO THE ':' CHAR
*	INY		AND TO THE FOLLOWING CHARACTER

**** ENTER NAME STATEMENT

XQUEST	CMPA	#$3F	IS IT '?' FOR ENTER NAME?
	BNE	XA		BRANCH IF NOT
	SEC		TURN HIGH BIT ORDER ON TO INDICATE
	ROR	IFLAG	PROCESSING NAME COMMAND
	BRA	TAKEIN	NOW USE THE ACCEPT LOGIC

**** ACCEPT STATEMENT

XA	CMPA	#$41	SEE IF WE HAVE AN ACCEPT STATEMENT
	BNE	XC		BRANCH IF NOT
	LDX	CURAD	SAVE ADDRESS OF THE 'A' STATEMENT
	STX	LST	NOTE: WILL INCLUDE CONDITIONALS

TAKEIN	LDAA	#$3F	DISPLAY '?' PROMPTING CHARACTER
	JSR	OUTCH

	LDAB	#$27	CHRS GET STORED BACKWARD (offset)
	STAB	OFFSET	store it as offset for hhhh,X at ACHR2
ACHR	JSR	INCH	GET AN INPUT CHARACTER
	STAA	STORA
	CMPA	#$08	IS IT A BACKSPACE?
	BNE	ACHR1	BRANCH IF NOT
	INC	OFFSET	ELSE FORGET ABOUT LAST CHARACTER
	BRA	ACHR	UNCONDITIONAL
ACHR1	CMPA	#CR	WAS IT A CARRIAGE RETURN?
	BNE	ACHR2	NO - SKIP AHEAD
	LDAA	#$00	YES - CONVERT CR TO EOL
	STAA	STORA

ACHR2	LDX	#CHRS	load address to index
	LDAA	OFFSET	the offset - 'X' in 6502
	JSR	IND_X	go get the address + offset
	LDAA	STORA
	STAA	0,X	AND SAVE IT FOR MATCH STATEMENT
	TST	IFLAG	SEE IF GETTING NAME FIELD
	BPL	ACHR3	BRANCH IF NOT, ELSE SAVE IN NAME FIELD ALSO

	STAA	$28,X	store it in NAME,X also

ACHR3	CMPA	#$00	IS IT DONE YET?
	BEQ	ADONE	BRANCH IF HE HAS SIGNALED END
	DEC	OFFSET	ELSE BUMP -1 FOR NEXT INPUT
	BPL	ACHR	AND GO GET IT IF ROOM STILL LEFT
ADONE	JSR	SAVCR	DO A CR/LF TO LET GUY KNOW
	LDX	STORX	retrieve the original X from ACHR2
	JMP	FWD

**** COMPUTE STATEMENT - adapted for 6800 (dhh)

XC	CMPA	#$43	'C'?
	BEQ	XC1	yes, go do it
	JMP	XM	no, check for 'M'

XC1	JSR	GETIDX	get index pointer for result variable
	STAA	ANSX	store it in a temp loc.
	CLR	RESULT	clear out the RESULT area
	CLR	RESULT+1
	INC	STORY	+1 Y, points to '='
	LDAA	#$2B	set 1st operation to '+'
	STAA	STORX	this holds the 'X' from 6502 code
	BRA	OPWRAP	go save and set up WORK area


CMPLOOP	INC	STORY	+1 to next char
	LDAA	STORY	load it
	JSR	IND_Y	go manufacture a 6502-style (xxxx),Y
	LDAA	0,X	load from that addr
	BMI	ISOPR	if bit 7 set, branch
	CMPA	#$2F	is '/'?
	BLT	ISOPR	if <, branch there
	CMPA	#$3A
	BGE	NOTNMB	if >=, branch there

	ANDA	#$0F	strip high nybble
	RORA		and spin
	RORA
	RORA
	RORA		leave bit 3 in Carry

	LDAB	#$04	4 bits to roll into WORK
BITROLL	ROL	WORK+1	ripple Carry into WORK
	ROL	WORK	for 16 bits
	ASLA		put next bit into Carry
	DECB		-1 counter
	BNE	BITROLL	>0 then loop
	BEQ	CMPLOOP	else get next char or operation

NOTNMB	JSR	VTRANS	transfer variable to WORK area
	JMP	CMPLOOP	go get next char/digit/etc

**** GOT AN OPERATION - FIRST PERFORM PREVIOUS REQUEST

ISOPR	STAA	STORX		SAVE NEW OPERATION IN TEMP FOR NOW
	LDAA OPRATN		GET PREVIOUS OPERATION
	CMPA #$2D		WAS IT A '-' FOR SUBTRACT?
	BEQ	OPMINUS		BRANCH IF YES (otherwise, assume +)

	CLC
	LDX	#WORK+1
BCD_ADD	LDAA	WORK+1		WORK AREA, LSB 1ST
	ADCA	RESULT+1	ADD TO RESULT AREA
	DAA			DECIMAL ADJUST
	STAA	RESULT+1	STORE IN RESULT AREA	
	LDAA	WORK		WORK AREA, NOW MSB
	ADCA	RESULT		ADD TO RESULT AREA
	DAA			DECIMAL ADJUST
	STAA	RESULT		STORE IN RESULT AREA
	JMP 	OPWRAP		GO WRAP UP THE OPERATION

* SUBTRACTION ROUTINE ADAPTED FROM ROB'T FINDLEY'S "6800 SOFTWARE
* GOURMET GUIDE & COOKBOOK," SECT 6, PG 4. HAYDEN PUB., 1976

OPMINUS	LDX	#WORK	set X to start of WORK area
BCD_SUB	LDAA	#$9A	100s compliment
	SUBA	1,X	
	ADDA	3,X
	DAA
	STAA	3,X
	LDAA	#$99	now do 100s/1000s with either
	ADCA	#$00	99s or 100s compliment, as needed
	SBCA	0,X
	ADCA	2,X
	DAA
	STAA	2,X

OPWRAP	LDAA STORX	the new operation
	STAA OPRATN	store new operation
	BEQ CMPDONE	DONE IF IT WAS ZERO (EOL)
	BMI CMPDONE	OR DELETE CHARACTERS (FROM FILLING)
	CLR WORK	clear WORK area
	CLR WORK+1
	BRA CMPLOOP	go do more

CMPDONE	LDAA	ANSX		get the 'X' from temp loc.
	BPL	TOVRIB		bit 7 clear, regular A-Z variable, go store

	LDAA	RESULT		else ('$=x'), use RESULT for value
	STAA	WORK		put it in WORK
	LDAA	RESULT+1
	STAA	WORK+1
	JSR	CNVDSP+3	convert from WORK to display form (with hop)
	LDX	#CHRS+39	or, $2A -- back of CHRS
	LDAB	#$03		for 4 digits
TALOOP	LDAA	$6A,X		this is NUMDSP+4 ($2A+$6A=$94)
	STAA	0,X		this is CHRS, going backward
	DEX			-1 index
	DECB			-1 counter
	BPL	TALOOP		if >= 0 then loop
	BMI	XFWD		otherwise, done

TOVRIB	LDAB	RESULT		put RESULT
	LDX	#VARIBS		into appropriate variable
	LDAA	ANSX		
	JSR	IND_X
	STAB	0,X
	LDAB	RESULT+1
	STAB	1,X

XFWD	JMP	FWD		and go do the next one


**** PROCESS MATCH STATEMENT

XM	CMPA #$4D	IS IT 'M' FOR MATCH?
	BEQ	MDEY	yes, go do it
	JMP	XU	no, LONG BRANCH IF NOT
MDEY	DEC	STORY		BACK UP ONE FOR WHAT FOLLOWS
MCHKX	INC	STORY		POINT TO MATCH CHARACTER
	LDAA #$27	START AT FIRST ACCEPTED CHARACTER
	STAA	OFFSET	for IND_X routine
MCHK	LDAA	STORY
	JSR	IND_Y	set up proper addr in X for the LDAA 0,X
	LDAA	0,X	GET THE MATCH CHARACTER
	BEQ MXY		THEY HAVE MATCHED TO END OF 'M:' STMT

	STAA	STORA	save the match char
	LDX	#CHRS
	LDAA	OFFSET
	JSR	IND_X
	LDAB	0,X	set up and get char from CHRS area
	CMPB	STORA	CHECK FOR MATCH
	BNE MXNMCH	BRANCH IF MATCH FAILED
	INC	STORY	ELSE BUMP TO NEXT PAIR OF CHARACTERS
	DEC	OFFSET
	BPL MCHK	AND GO CHECK IF STILL DATA LEFT
MXY	LDAB #$59	BOTH EQUAL - SET FLAG TO 'Y'
	BRA MX		UNCONDITIONAL

MXNMCH	LDAA	STORA	get the match character
	CMPA #$24	IS IT '$' FOR VARIABLE REQUEST?
	BEQ MNUMB	YES - MATCH TO NUMERIC VARIABLE
	CMPA #$2C	IS IT A COMMA GROUP SEPARATOR?
	BEQ MXY		YES - MATCHED SO FAR - SET IT AS YES

MCOMMA	INC	STORY	NO - SO NEED TO SKIP AHEAD TO COMMA
	LDAA	STORY
	JSR	IND_Y	set up for proper CURAD indexed address
	LDAA	0,X	get the char
	BEQ MXSETN	IF TO EOL, THERE IS NO MORE TO CHECK
	CMPA #$2C	IS IT A COMMA CHARACTER?
	BEQ MCHKX	YES, RESTART COMPARE AT NEXT MATCH CHARACTER
	BNE MCOMMA	NO, LOOP IN SEARCH OF A COMMA

MCOMX	LDAB	STORY	RESET Y TO CURRENT LINE POINTER
	STAB	NTEMPB	temp loc. to store in
	BNE MCOMMA	AND GO LOOK FOR NEXT COMMA

MNUMB	INC	STORY	VARIABLE, BUMP TO VAR. ID (this is 'Y' in 6502)
	LDAA	OFFSET	save several things that are about to be clobbered
	STAA	NTEMPOF

	JSR	CNVDSP
	
	LDX	#CHRS+$27	set up addr to check input
	STX	STORX
	LDX	#NUMDSP+4	set up addr to get a varib digit
	STX	NTEMPY		save it here
MXNOLP	LDAA	0,X		get one digit from NUMDSP
	BEQ	MXDIFF		branch if end, might be match
	LDX	STORX		set up X for end of CHRS area
	LDAB	0,X		load a digit from CHRS area
	CBA			compare current NUMDSP and CHRS
	BNE	MCOMX		if no match, branch up
	DEX
	STX	STORX
	LDX	NTEMPY
	DEX
	STX	NTEMPY
	CPX	#$008F
	BNE	MXNOLP		no, loop

MXDIFF	LDAB	NTEMPB	RESET Y TO CURRENT LINE POINTER
	INCB		BUMP TO CHARACTER AFTER VARIABLE
	STAB	STORY
	JMP	MCHK	UNCONDITIONAL CONTINUE CHECKING

MXSETN	LDAB #$4E	GET 'N' - MATCH WAS UNSUCCESSFUL
MX	STAB FLG	STORE IT
	JMP	FWD	UNCONDITIONAL FORWARD TO NEXT LINE

**** PROCESS USE SUBROUTINE STATEMENT

XU	CMPA #$55	IS IT A 'U' FOR USE SUBROUTINE?
	BNE XJ		BRANCH IF NOT
	LDAA	STORY
	JSR	IND_Y
	LDAA	0,X	GET DESTINATION
	PSHA		SAVE THE LABEL CHARACTER
	JSR FWD1	MOVE TO START OF NEXT LINE
	STX	STORX
	LDX	CURAD
	STX	RETURN	SAVE FOR RETURN ADDRESS
	LDX	STORX	get back original X
	PULA		GET DESTINATION BACK
	BNE JDO		NO GO HANDLE AS JUMP STATEMENT

**** PROCESS JUMP STATEMENT

XJ	CMPA #$4A	IS IT 'J' FOR JUMP STATEMENT?
	BNE XS		BRANCH IF NOT
	LDAA	STORY
	JSR	IND_Y
	LDAA	0,X	GET DESTINATION

JDO	STAA IFLAG	SAVE LABEL CHARACTER
	CMPA #$2A	HAVE '*' TO REQUEST RETURN TO BEGINNING?
	BEQ IREST	BRANCH IF SO
	CMPA #$41	SEE IF A LABELED JUMP
	BNE JF		IF NOT 'A', IT'S A NORMAL JUMP

	STX	STORX
	LDX	LST
	STX	CURAD
	BRA ILNEXT	UNCONDITIONAL

JF	JSR SETBGN+3	AND GET BACK TO START OF PROGRAM

FNDMRK	LDAA	STORY
	JSR	IND_Y
	LDAA	0,X	GET FIRST CHARACTER
	CMPA #$2A	IS IT '*' FOR A MARKER?
	BNE FMNEXT	NOPE - GO AHEAD TO NEXT LINE
	INC	STORY	ELSE BUMP TO MARKER CHARACTER
	LDAA	1,X	GET LABEL
	CMPA IFLAG	SEE IF IT'S THE ONE WE WANT
	BEQ ILNEXT	YES - GO EXECUTE IT
FMNEXT	JSR FWD1	ELSE GO TO NEXT LINE
	BCS FNDMRK	AND CONTINUE LOOKING
IREST	JMP RESTRT	INDIRECT TO RESTRT

**** STOP STATEMENT

XS	CMPA #$53	IS IT AN 'S' FOR STOP STATEMENT?
	BNE XE		BRANCH IF NOT
	JMP START	ELSE RETURN TO EDITOR START

**** EXIT FROM SUBROUTINE

XE	CMPA #$45	IS IT AN 'E'?
	BNE XR		BRANCH IF NOT
	LDAA RETURN+1	MOVE RETURN ADDRESS TO CURAD
	BEQ XXFWD	SKIP LINE IF NOT SET
	STAA CURAD+1
	LDAA RETURN
	STAA CURAD
	LDAA	#$00	NOW SET TO NOT USED AGAIN
	STAA RETURN+1
	BRA ILNEXT	UNCONDITIONAL

**** REMARK STATEMENT

XR	CMPA #$52	IS IT AN 'R'?
	BNE XT		BRANCH IF NOT - ELSE SKIP THE LINE
XXFWD	JMP FWD		CAN'T BRANCH THAT FAR ALONE

**** TYPE STATEMENTS AND SYNTAX ERRORS

XT	CMPA #$54	IS IT A VALID 'T' STATEMENT?
	BEQ TE		BRANCH IF SO
	DEC	STORY	ELSE BACK UP TO ORIGINAL START
	DEC	STORY
TE	JSR PRT		NOW PRINT THE LINE
ILNEXT	JSR SKPJNK	CURAD IS SET - SKIP OVER LEADING JUNK
	JMP LSTART	AND GO START ON THE LINE

**** PRINT A LINE FROM CURRENT LOCATION TO
**** NEXT EOL AND THEN SET UP FOR NEXT LINE

PRT	LDAA	STORY
	JSR	IND_Y
	LDAA	0,X	GET THE CURRENT CHARACTER
	BEQ LINEND	BRANCH IF TO END OF LINE
	TST IFLAG	SEE IF IN EDITOR
	BMI CHROUT	IF SO, DON'T LOOK FOR '$'

	CMPA #$24	IS IT A SPECIAL ONE ('$')?
	BNE CHROUT	BRANCH IF NOT
	INC	STORY	ELSE BUMP TO NEXT ONE
	LDAA	1,X	GET VARIABLE
	CMPA #$3F	IS IT REQUEST FOR NAME ('?')?
	BEQ NAMEO	BRANCH IF YES
	JSR CNVDSP	CONVERT VARIABLE TO DISPLAY
	LDAB #$04	GOT 5 BYTES POSSIBLE

VBDISP	LDX	#NUMDSP
	TBA
	CMPA	#$00
	JSR	IND_X
	LDAA	0,X	GET A CHARACTER
	BEQ CHROUT+3	BRANCH IF TO END OF VARIABLE
	JSR OUTCH	ELSE OUTPUT IT
	DECB		AND COUNT IT
	BPL VBDISP	UNCONDITIONAL LOOP

NAMEO	LDX	#NAME+$27	load up NAME area
NAMEO1	LDAA	0,X	load an indexed char from NAME
	BEQ CHROUT+3	BRANCH IF TO END OF NAME
	JSR OUTCH	print it
	DEX		-1 the index (chars are in there backward)
	BRA NAMEO1	UNCONDITIONAL

CHROUT	JSR OUTCH
	INC	STORY
	BPL PRT		LOOP IF NOT TOO MANY
	BMI SETBGN	RESET TO BEGINNING IF PAST THE END
LINEND	JSR SAVCR	OUTPUT CR AND LF

**** ENTER HERE TO SKIP A LINE WITHOUT PRINT
**** AND INITIALIZE FOR THE NEXT LINE

FWD1	LDAA STORY
	JSR IND_Y
	LDAA	0,X	GET A CHARACTER
	BEQ SCURAD	BRANCH IF END OF LINE
	INC	STORY	ELSE BUMP TO NEXT ONE
	BPL FWD1	LOOP IF NOT TOO MANY
	BMI SETBGN	RESET TO BEGINNING IF PAST THE END

**** HERE FIXES UP CURAD TO POINT TO BEGINNING OF A LINE
**** CURAD SHOULD INDEX END OF LINE (WITH Y) ON ENTRY

SCURAD	LDX	CURAD2
	INX
	STX	CURAD

**** HERE TO SKIP PAST LEADING JUNK ON A LINE

SKPJNK	LDAA #$FF	SET UP Y THIS WAY
	STAA	STORY
SJLOOP	INC	STORY	INCREMENT TO NEXT CHARACTER
	TST IFLAG	SEE IF IN EDIT MODE
	BMI SJRTS	DON'T TRY SKIPPING JUNK IF SO
	LDAA	STORY
	JSR	IND_Y
	LDAA	0,X	GET CHARACTER TO LOOK AT
	BMI SJLOOP	IGNORE DELETE CHARACTER ALSO
	CMPA #$2A	LOOK FOR '*' LABEL MARKER
	BEQ SJRTS	RETURN IF FOUND
	CMPA #$3F	LOOK FOR POSSIBLE OPERATION CHARACTER
	BLT SJLOOP	CONTINUE SKIPPING IF TOO LOW
SJRTS	SEC		SET CARRY FOR BRANCHES AFTER RETURN
	RTS		AND BEFORE RETURN

**** SET UP BEGINNING ADDRESS OF USER AREA

SETBGN	JSR SAVCR	START ON A NEW LINE
	LDX	#$0700	this is the start of user RAM area
	STX	CURAD
	STX	LST
	BRA	SKPJNK	UNCONDITIONAL

**** COMPUTE INDEX FOR A VARIABLE
* OFFSET will hold value for generating proper X addr

GETIDX	LDAA	STORY	get 'Y' index value
	JSR	IND_Y	go generate the proper, indexed addr
	LDAA	0,X	load variable letter at current addr + offset
	SUBA	#$41	SUBTRACT 'A' TO MAKE RELATIVE TO ZERO
	ASLA		TIMES TWO BYTES PER VARIABLE
	STAA	OFFSET	store this in 6502 'X' holder for indexed addr
*			MOVE TO INDEX REGISTER
	RTS		AND RETURN

**** TRANSFER A VARIABLE'S DATA TO WORK AREA

VTRANS	JSR	GETIDX	GET INDEX POINTER FIRST
	LDX	#VARIBS	load addr to index
	LDAA	OFFSET	the offset - 'X' in 6502
	JSR	IND_X
	LDAA	0,X
	STAA	WORK
	LDAA	1,X
	STAA	WORK+1
	RTS
	
**** CONVERT A VARIABLE TO DISPLAY FORM
* rewritten to reflect only pos. numbers 0-9999  -dhh

CNVDSP	JSR VTRANS	MOVE TO WORK AREA
	LDX	#NUMDSP+4	the number display area
ISPL1	CLC		TURN OFF SIGNIFICANCE INDICATOR
	ROR	SIGNIF
	LDAA	WORK	first DIGIT IS HIGH ORDER OF THIS
	LSRA
	LSRA
	LSRA
	LSRA
	JSR TOOUT
	LDAA	WORK	GET second DIGIT
	JSR TOOUT	PUT TO OUTPUT AREA
	LDAA	WORK+1	third DIGIT IS HIGH ORDER OF THIS
	LSRA
	LSRA
	LSRA
	LSRA
	JSR TOOUT
	LDAA	WORK+1	LOW ORDER IS fourth DIGIT
	JSR TOOUT
	TST SIGNIF	SEE IF IT HAD ANY SIGNIFICANT CHARS
	BMI ISPL2	SKIP NEXT IF YES
	DEX		ELSE KEEP THE LAST ZERO THERE
ISPL2	LDAA	#$00	INSERT END OF LINE MARKER
	STAA 0,X
	RTS		AND RETURN

**** CONVERT CURRENT VALUE TO ASCII AND PUT TO OUTPUT AREA

TOOUT	ANDA #$0F	KEEP ONLY LOW ORDER
	ORAA #$30	MAKE IT ASCII
	STAA 0,X	SAVE REGARDLESS
	TST SIGNIF	SEE IF SIGNIFICANCE STARTED
	BMI SETSIG	YES - ALL ARE IMPORTANT NOW
	CMPA #$30	ELSE SEE IF SHOULD START NOW
	BNE SETSIG	IMPORTANT IF NOT ZERO
	RTS		ELSE RETURN

SETSIG	SEC		SET SIGNIFICANCE BIT ON
	ROR	SIGNIF	ALWAYS
	DEX		AND POINT TO NEXT AVAILABLE POINTER
PGMEND	RTS		AND THEN RETURN

**** Bob Applegate's KIM-1 specific IN/OUT/CRLF routines
**** 6800: only CRLF needed for HM-68

SAVCR	PSHA
	LDAA	#$0A
	JSR	OUTCH
	LDAA	#$0D
	JSR	OUTCH
	PULA
	RTS

**** New Tiny PILOT commands added by Bob Applegate.
**** Appeared in MICRO, Aug. 1980, issue 27, pg. 21
**** 
**** I:x -- Input a positive number into any variable x
**** P:x -- Puts a random number 0-99 into variable x (REPLACED -dhh)
**** L:x -- Call ML subroutine loc in variable x. Starting
*            addr of one of 3 variables to be PRE-STORED as:
*		NAME	Zero Pg Addrs
*		A	$A0, $A1
*		B	$A2, $A3
*		C	$A4, $A5


EXTRA	CLR	IFLAG	this will clear high bit for editor
	INC	STORY	point to ':'
	INC	STORY	and the next character

**** CALL ML SUBROUTINE STATEMENT
**** Modified by DHH to remove self-modifying code.

	CMPA #$4C	is it the L command
	BNE XP		no, go to P command
XL	JSR GETIDX	compute the index

	LDX	#$00A0	start of Bob's special jump vectors
	LDAA	OFFSET
	JSR	IND_X

	LDAA	1,X	get the low-order byte from table
	STAA STORZ+1	and store in a temp loc.
	LDAA	0,X	get the high-order byte
	STAA STORZ	and store in a temp loc.
STRSUB	JSR GO_L	subroutine will return here
	JMP FWD		all done, return to PILOT
GO_L	LDX	STORZ
	JMP	0,X	indirect jump to ML program

**** GENERATE PSEUDO-RANDOM NUMBER STATEMENT
* ADAPTED FROM ROB'T FINDLEY "6800 SOFTWARE GOURMET GUIDE & COOKBOOK,"
* SECT 3, PG 21. HAYDEN PUB., 1976.  Generates 0-85 decimal
* with result left in variable indicated after P:x --dhh

XP	CMPA #$50	is it the P command
	BNE XI		nope, go to I command
	JSR GETIDX	compute the index

RANDOM	LDX	#RANDUM	set pointer to random number
	LDAA	0,X	fetch number
	ROLA		perform a series of operations on it
	EORA	0,X
	RORA
	INC	1,X	increment the addend
	ADDA	1,X	add it in
	BVC	SKIP	if V=0, just once
	INC	1,X
SKIP	ANDA	#$7F
	ADDA	#$00	add nothing (ADDA needed to use DAA)
	DAA		decimal adjust
	STAA	0,X	store new random number in RANDUM

	LDX	#VARIBS	pick up the index
	LDAA	OFFSET
	JSR	IND_X		generate it
	LDAA	RANDUM
	STAA	1,X	store in variable's LSB
	CLR	0,X	clear out the MSB
	JMP FWD		back to PILOT

**** INPUT A POSITIVE NUMBER STATEMENT (up to 4 decimal digits)

XI	CMPA #$49	see if it's the I command
	BNE XX		no, go to X command
	LDAA	#$3F	get a '?'
	JSR OUTCH	output it as a prompt
	CLR BOB1	clear out, especially this temp variable
	CLR BOB2	ditto
XIINPT	JSR INCH	get input
	CMPA #CR	cr?
	BEQ XINDX	yes, branch to get index
	SUBA #$30	turn ASCII into BCD
	LDAB #$04	get ready to multiply by 10
XILOOP	CLC		clear things first
	ASL	BOB2	multiply
	ROL	BOB1	multiply
	DECB		again?
	BNE XILOOP	yes, then loop
	CLC		clear things up again
	ADCA BOB2	add the new digit
	STAA BOB2	store the answer
	JMP XIINPT	do it all over again

XINDX	JSR GETIDX	get the index
	LDX	#VARIBS
	LDAA	OFFSET
	JSR	IND_X

	LDAA	BOB1	get first part of answer
	STAA	0,X	store it at variable
	LDAA	BOB2	get the next part
	STAA	1,X	and store that
	JSR	SAVCR	start a new line
	JMP	FWD	all done, return to PILOT


**** X: Statement (swap/transfer NAME and STRING) -- DHH

XX	CMPA	#$58	see if it's the X: statement
	BNE	GOBACK	no, out of extra/new statements

	LDX	#CHRS+$27	base addr for index
	LDAA	#$27	will go 40 times/chars
	STAA	STORA	counter
XXLOOP	LDAB	$28,X	NAME character
	LDAA	$A3,X	STRING char
	STAB	$A3,X	swap 'em: NAME to STRING
	STAA	$28,X	STRING to NAME
	STAA	$0,X	*and* CHRS
	DEX		-1 index
	DEC	STORA	-1 counter
	BPL	XXLOOP	if >= 0, loop
	JMP	FWD	otherwise, done and restart

GOBACK	JMP XQUEST	not a new command, check old ones

**** ZAP editor command by Dave Hassler, 2023.  Clears all
**** variables (except Bob's special ML call variables)
**** and user RAM to $7EFF for that fresh, power-up feeling.
**** The equivalent of BASIC's 'NEW' command.

ZAPRAM	LDX #$0000	first, Zero Pg
ZLOOP	CLR 0,X		store '00'
	INX
	CPX #$0087	not past this loc.
	BNE ZLOOP

	LDX	#$0700	next, user memory. first page to clear
MLOOP	CLR	0,X
	INX
	CPX	#$7EFF
	BNE	MLOOP
	JMP	START	jump back to START




**** OUTPUT A WELCOME BANNER BEFORE EXECUTION (DHH)

WELCOM	JSR 	SAVCR		CRLF
	LDX	#TITLE
	JSR	PDATA1
	LDAA	#$76
	STAA	RANDUM		seed RND generator 1st time
	LDAA	#$01
	STAA	RANDUM+1
	RTS

TITLE	FCB	$0A,$0D
	FCC	"6800 Tiny PILOT v2.2"
	FCB	$0A,$0D,$04
	FCC	"6502 orig Nicholas Vrtis 1979."
	FCC	" 6800 port Dave Hassler 2024."

EXITMSG	FCC	"Script start/end: $0700/$"
	FCB	$04

**** do a 6502-style indirect-indexed-Y
* IN: ACCA = 'Y' (X = LOCATION (here, current address in user RAM))
* returns CURAD + offset 'Y' IN CURAD2 and X

IND_Y	BEQ	ZERO_Y
	STX	STORX
	LDX	CURAD
	STX	CURAD2
LOOP_Y	INX
	DECA
	BNE	LOOP_Y
	STX	CURAD2
	RTS	
ZERO_Y	STX	STORX
	LDX	CURAD
	STX	CURAD2
	RTS

**** do a 6502-style indexed-X
* IN: ACCA = OFFSET, X = LOC. TO START.
* OUT: X = LOC. INDEXED BY OFFSET

IND_X	BEQ	FIN_X	IF THE OFFSET IS ZERO, JUST RETURN
LOOP_X	INX
	DECA
	BNE	LOOP_X
	LDAA	RANDUM+1	add more 'randomness' to P:
	ADDA	#$05		with each call to this routine
	STAA	RANDUM+1
FIN_X	RTS
